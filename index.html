<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HACK.SIM</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a0a;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  cursor: none;
  user-select: none;
}
#game-canvas {
  position: relative;
  width: 100vw;
  height: 100vh;
}

/* HUD */
#hud {
  position: fixed;
  top: 0; left: 0; right: 0;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(0,0,0,0.8);
  border-bottom: 1px solid #00ff41;
  z-index: 100;
  font-size: 14px;
}
.maplv-control {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
#maplv-select {
  background: #0a0a0a;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 13px;
  padding: 2px 4px;
  cursor: pointer;
}

/* Bottom HUD */
#bottom-hud {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  background: rgba(0,0,0,0.8);
  border-top: 1px solid #00ff41;
  z-index: 100;
  font-size: 13px;
}

/* Inventory panel (left side) */
#inventory-panel {
  position: fixed;
  top: 50px;
  left: 10px;
  width: 260px;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
  background: rgba(0,0,0,0.85);
  border: 1px solid #00ff41;
  padding: 8px;
  z-index: 100;
  font-size: 12px;
}
#inventory-panel::-webkit-scrollbar { width: 6px; }
#inventory-panel::-webkit-scrollbar-track { background: #111; }
#inventory-panel::-webkit-scrollbar-thumb { background: #00ff41; }
#inventory-panel h3 {
  color: #ffaa00;
  font-size: 13px;
  margin-bottom: 6px;
  text-align: center;
}
.equip-section { margin-bottom: 8px; }
.equip-section .section-title {
  color: #00ff41;
  font-size: 11px;
  margin-bottom: 4px;
  border-bottom: 1px solid #333;
  padding-bottom: 2px;
}
.equip-slot {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 2px 0;
  padding: 3px 4px;
  border: 1px solid #333;
  cursor: pointer;
  min-height: 22px;
}
.equip-slot:hover { border-color: #ffaa00; }
.equip-slot .slot-label { color: #555; font-size: 10px; margin-right: 4px; white-space: nowrap; }
.equip-slot .slot-item { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 11px; }
.equip-slot.empty .slot-item { color: #333; font-style: italic; }
.equip-slot.common { border-color: #aaa; background: rgba(170,170,170,0.05); }
.equip-slot.common .slot-item { color: #aaa; }
.equip-slot.uncommon { border-color: #00ff41; background: rgba(0,255,65,0.05); }
.equip-slot.uncommon .slot-item { color: #00ff41; }
.equip-slot.rare { border-color: #4488ff; background: rgba(68,136,255,0.05); }
.equip-slot.rare .slot-item { color: #4488ff; }
.equip-slot.epic { border-color: #aa44ff; background: rgba(170,68,255,0.05); }
.equip-slot.epic .slot-item { color: #aa44ff; }
.equip-slot.legendary { border-color: #ffaa00; background: rgba(255,170,0,0.08); }
.equip-slot.legendary .slot-item { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }
.equip-slot.unique { border-color: #ff2222; background: rgba(255,34,34,0.08); }
.equip-slot.unique .slot-item { color: #ff2222; text-shadow: 0 0 8px #ff2222; }

.inv-separator {
  border: none;
  border-top: 1px solid #333;
  margin: 6px 0;
}

.inv-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 2px 0;
  padding: 3px 4px;
  border: 1px solid transparent;
  cursor: pointer;
  position: relative;
}
.inv-item:hover { border-color: #00ff41; }
.inv-item .inv-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 11px; }
.inv-item .inv-type { font-size: 9px; color: #666; margin-left: 4px; white-space: nowrap; }
.inv-item .inv-trash {
  margin-left: 4px;
  color: #ff4444;
  cursor: pointer;
  font-size: 11px;
}
.inv-item .inv-trash:hover { color: #ff8888; }
.inv-item.common .inv-name { color: #aaa; }
.inv-item.uncommon .inv-name { color: #00ff41; }
.inv-item.rare .inv-name { color: #4488ff; }
.inv-item.epic .inv-name { color: #aa44ff; }
.inv-item.legendary .inv-name { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }
.inv-item.unique .inv-name { color: #ff2222; text-shadow: 0 0 8px #ff2222; }

.inv-page-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 6px;
  margin-top: 4px;
  font-size: 10px;
  color: #888;
}
.inv-page-btn {
  background: none;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  padding: 1px 6px;
  cursor: pointer;
}
.inv-page-btn:hover { background: rgba(0,255,65,0.2); }
.inv-page-btn:disabled { color: #555; border-color: #555; cursor: default; }
.inv-page-btn:disabled:hover { background: none; }

/* Tooltip */
.item-tooltip {
  position: fixed;
  background: rgba(0,0,0,0.95);
  border: 1px solid #00ff41;
  padding: 8px 10px;
  font-size: 11px;
  z-index: 500;
  pointer-events: none;
  max-width: 250px;
  line-height: 1.5;
  display: none;
}
.item-tooltip .tt-name { font-size: 13px; font-weight: bold; margin-bottom: 4px; }
.item-tooltip .tt-type { color: #888; font-size: 10px; }
.item-tooltip .tt-ilv { color: #888; font-size: 10px; }
.item-tooltip .tt-stats { margin: 4px 0; }
.item-tooltip .tt-affix { color: #00ccff; }
.item-tooltip .tt-shape { color: #ffcc00; font-size: 10px; }
.item-tooltip .tt-auto { color: #ff66aa; font-size: 10px; }
.item-tooltip.common .tt-name { color: #aaa; }
.item-tooltip.uncommon .tt-name { color: #00ff41; }
.item-tooltip.rare .tt-name { color: #4488ff; }
.item-tooltip.epic .tt-name { color: #aa44ff; }
.item-tooltip.legendary .tt-name { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }
.item-tooltip.unique .tt-name { color: #ff2222; text-shadow: 0 0 8px #ff2222; }

/* Enemies */
.enemy {
  position: absolute;
  text-align: center;
  transition: opacity 0.2s;
  pointer-events: none;
}
.enemy .label {
  font-size: 14px;
  font-weight: bold;
  white-space: nowrap;
}
.enemy .hitbox {
  position: absolute;
  top: -4px;
  left: 50%;
  width: 20px;
  height: 20px;
  transform: translateX(-50%);
  border: 1px solid rgba(0,255,65,0.25);
  border-radius: 50%;
  pointer-events: none;
}
.enemy.elite .hitbox {
  border-color: rgba(255,170,0,0.3);
}
.enemy .hp-bar {
  width: 100%;
  height: 3px;
  background: #333;
  margin-top: 2px;
}
.enemy .hp-fill {
  height: 100%;
  background: #00ff41;
  transition: width 0.15s;
}
.enemy.elite .label { color: #ffaa00; }
.enemy.elite .hp-fill { background: #ffaa00; }

/* Attack effect */
.attack-effect {
  position: absolute;
  color: #00ff41;
  font-size: 18px;
  font-weight: bold;
  pointer-events: none;
  animation: attackPop 0.4s ease-out forwards;
  z-index: 50;
}
@keyframes attackPop {
  0% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(2); }
}

/* Sub attack effect */
.sub-attack-effect {
  position: absolute;
  color: #ff66aa;
  font-size: 14px;
  font-weight: bold;
  pointer-events: none;
  animation: attackPop 0.4s ease-out forwards;
  z-index: 50;
}

/* Chain line effect */
.chain-effect {
  position: absolute;
  height: 2px;
  background: #ff66aa;
  pointer-events: none;
  transform-origin: left center;
  animation: chainFade 0.3s ease-out forwards;
  z-index: 49;
}
@keyframes chainFade {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

/* Orbit effect */
.orbit-marker {
  position: absolute;
  width: 8px;
  height: 8px;
  background: #ff66aa;
  border-radius: 50%;
  pointer-events: none;
  z-index: 49;
  box-shadow: 0 0 6px #ff66aa;
}

/* Damage numbers */
.damage-number {
  position: absolute;
  font-size: 16px;
  font-weight: bold;
  color: #ff4444;
  pointer-events: none;
  animation: floatUp 0.8s ease-out forwards;
  z-index: 50;
}
.damage-number.crit { font-size: 22px; color: #ffaa00; }
.damage-number.sub-dmg { color: #ff66aa; font-size: 14px; }
@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-40px); }
}

/* Drops */
.drop {
  position: absolute;
  font-size: 12px;
  padding: 2px 6px;
  border: 1px solid;
  cursor: pointer;
  animation: dropBounce 0.3s ease-out;
  z-index: 30;
}
.drop.common { color: #aaa; border-color: #aaa; }
.drop.uncommon { color: #00ff41; border-color: #00ff41; }
.drop.rare { color: #4488ff; border-color: #4488ff; }
.drop.epic { color: #aa44ff; border-color: #aa44ff; }
.drop.legendary { color: #ffaa00; border-color: #ffaa00; text-shadow: 0 0 8px #ffaa00; }
.drop.unique { color: #ff2222; border-color: #ff2222; text-shadow: 0 0 8px #ff2222; }
@keyframes dropBounce {
  0% { transform: translateY(-20px); opacity: 0; }
  100% { transform: translateY(0); opacity: 1; }
}

/* Upgrade panel (right side) */
#upgrade-panel {
  position: fixed;
  top: 50px;
  right: 10px;
  width: 220px;
  background: rgba(0,0,0,0.85);
  border: 1px solid #00ff41;
  padding: 8px;
  z-index: 100;
  font-size: 12px;
}
#upgrade-panel h3 {
  color: #ffaa00;
  font-size: 13px;
  margin-bottom: 6px;
  text-align: center;
}
.upgrade-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 3px 0;
  padding: 3px 4px;
}
.upgrade-btn {
  background: none;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  padding: 2px 8px;
  cursor: pointer;
  white-space: nowrap;
}
.upgrade-btn:hover { background: rgba(0,255,65,0.2); }
.upgrade-btn:disabled { color: #555; border-color: #555; cursor: default; }
.upgrade-btn:disabled:hover { background: none; }

/* Crosshair + splash range indicator */
#crosshair {
  position: fixed;
  border: 1px solid rgba(0,255,65,0.4);
  border-radius: 50%;
  pointer-events: none;
  z-index: 90;
  transform: translate(-50%, -50%);
}
#crosshair::after {
  content: '+';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #00ff41;
  font-size: 16px;
  font-weight: bold;
}

/* Status banner */
#status-banner {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 32px;
  color: #00ff41;
  z-index: 150;
  display: none;
  text-shadow: 0 0 20px #00ff41;
}
</style>
</head>
<body>

<div id="hud">
  <div>HACK.SIM</div>
  <div class="maplv-control">
    MapLv:<select id="maplv-select"></select>
  </div>
  <div>CREDITS: <span id="hud-credits">0</span></div>
  <div>SCORE: <span id="hud-score">0</span></div>
  <div><button id="save-btn" style="background:none;border:1px solid #00ff41;color:#00ff41;font-family:'Courier New',monospace;font-size:11px;cursor:pointer;padding:2px 6px;" onclick="event.stopPropagation();saveGame();this.textContent='SAVED';setTimeout(()=>this.textContent='SAVE',1000);">SAVE</button> <button id="reset-btn" style="background:none;border:1px solid #ff4444;color:#ff4444;font-family:'Courier New',monospace;font-size:11px;cursor:pointer;padding:2px 6px;" onclick="event.stopPropagation();if(confirm('Reset all progress?'))resetGame();">RESET</button></div>
</div>

<div id="bottom-hud">
  <div>CORES: <span id="hud-cores">1</span>/4</div>
  <div>ATK: <span id="hud-atk">10</span> | SPLASH: <span id="hud-splash">50</span> | CD: <span id="hud-cd">0.50</span>s</div>
  <div>CRIT: <span id="hud-crit">5</span>% x<span id="hud-critdmg">2.0</span></div>
  <div>KILLS: <span id="hud-kills">0</span></div>
</div>

<div id="inventory-panel">
  <h3>EQUIPMENT</h3>
  <div class="equip-section">
    <div class="section-title">â”€â”€ CORE â”€â”€</div>
    <div id="core-slots"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">â”€â”€ SUB â”€â”€</div>
    <div id="sub-slots"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">â”€â”€ MODULE â”€â”€</div>
    <div id="module-slots"></div>
  </div>
  <hr class="inv-separator">
  <div class="equip-section">
    <div class="section-title">â”€â”€ CORE [<span id="inv-count-core">0</span>/50] â”€â”€</div>
    <div id="inv-list-core"></div>
    <div class="inv-page-controls" id="inv-page-core"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">â”€â”€ SUB [<span id="inv-count-sub">0</span>/50] â”€â”€</div>
    <div id="inv-list-sub"></div>
    <div class="inv-page-controls" id="inv-page-sub"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">â”€â”€ MODULE [<span id="inv-count-mod">0</span>/50] â”€â”€</div>
    <div id="inv-list-mod"></div>
    <div class="inv-page-controls" id="inv-page-mod"></div>
  </div>
</div>

<div id="game-canvas"></div>
<div id="crosshair"></div>

<div id="status-banner"></div>

<div id="upgrade-panel">
  <h3>UPGRADES [Â¢<span id="hud-credits-panel">0</span>]</h3>
  <div id="upgrade-list"></div>
</div>

<div class="item-tooltip" id="item-tooltip"></div>

<script>
// ---- CONFIG ----
const CANVAS_PAD_TOP = 40;
const CANVAS_PAD_BOT = 40;
const SPAWN_INTERVAL = 0.3;
const ENEMY_TYPES = [
  { tag: 'SRV', baseHp: 20, speed: 30, credits: 2, score: 10 },
  { tag: 'NODE', baseHp: 15, speed: 45, credits: 2, score: 10 },
  { tag: 'FW', baseHp: 50, speed: 20, credits: 5, score: 30 },
  { tag: 'DB', baseHp: 80, speed: 15, credits: 8, score: 50 },
  { tag: 'PROXY', baseHp: 30, speed: 55, credits: 3, score: 20 },
];
const ELITE_TYPE = { tag: 'MAINFRAME', baseHp: 300, speed: 10, credits: 30, score: 200, elite: true };
const RARITIES = ['common','uncommon','rare','epic','legendary','unique'];
const RARITY_WEIGHTS = [50, 30, 14, 5, 1, 0.1];
const RARITY_AFFIX_COUNT = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4, unique: 5 };
const ATTACK_SHAPES = ['circle', 'line', 'cone', 'nova'];
const AUTO_MODES = ['nearest', 'chain', 'explode', 'orbit'];
const CORE_NAMES = [
  'Ping Flood','Port Scanner','SQL Injector','Buffer Overflow',
  'Zero-Day Exploit','Rootkit Launcher','Worm Deployer','Trojan Horse',
  'DDoS Cannon','Crypto Breaker','Firewall Piercer','Kernel Panic'
];
const SUB_NAMES = [
  'Packet Sniffer','Backdoor Agent','Keylogger Mk2','Spyware Beacon',
  'Brute Forcer','Phishing Relay','Adware Spreader','Botnet Node',
  'Proxy Chain','DNS Poisoner','Session Hijacker','Payload Dropper'
];
const MODULE_NAMES = [
  'Logic Amplifier','Cache Optimizer','Thread Scheduler','Memory Allocator',
  'Pipeline Booster','Signal Enhancer','Packet Compressor','Clock Multiplier',
  'Branch Predictor','Entropy Filter','Hash Accelerator','Codec Overdriver'
];

const AFFIX_POOL = [
  { id: 'flatAtk',    label: (v) => `ATK +${v}`,           gen: (ilv) => randInt(2 + ilv, 5 + ilv * 2) },
  { id: 'pctAtk',     label: (v) => `ATK +${v}%`,          gen: (ilv) => randInt(3, 8 + ilv) },
  { id: 'flatSplash', label: (v) => `Splash +${v}`,        gen: (ilv) => randInt(5, 15 + ilv * 2) },
  { id: 'pctCd',      label: (v) => `CD -${v}%`,           gen: (ilv) => randInt(2, 6 + Math.floor(ilv / 2)) },
  { id: 'critChance', label: (v) => `CritChance +${v}%`,   gen: (ilv) => randInt(1, 4 + Math.floor(ilv / 3)) },
  { id: 'critDmg',    label: (v) => `CritDMG +${v}%`,      gen: (ilv) => randInt(5, 15 + ilv) },
  { id: 'xpBonus',    label: (v) => `Credits +${v}%`,       gen: (ilv) => randInt(3, 8 + ilv) },
  { id: 'dropRate',   label: (v) => `DropRate +${v}%`,     gen: (ilv) => randInt(2, 5 + Math.floor(ilv / 2)) },
];

const INV_PAGE_SIZE = 5;
const MAX_INVENTORY = 50;

// ---- STATE ----
let state = {
  running: false,
  paused: false,
  mapLv: 1,
  spawnTimer: 0,
  score: 0,
  kills: 0,
  credits: 0,
  enemies: [],
  drops: [],
  equipped: {
    cores: [null, null, null, null],
    subs: [null, null, null, null],
    modules: [null, null, null, null],
  },
  cooldown: 0,
  mouseX: 0,
  mouseY: 0,
  upgrades: { atkMult: 1, rangeMult: 1, cdMult: 1, splashMult: 1, critChance: 0.05, critMult: 2, creditMult: 1, dropMult: 1 },
  skillLevels: {},
  inventories: { cores: [], subs: [], modules: [] },
  invPages: { cores: 0, subs: 0, modules: 0 },
  subCooldowns: [0, 0, 0, 0],
  orbitAngles: [0, 0, 0, 0],
  // Track explode kills per sub
  pendingExplosions: [],
};

const canvas = document.getElementById('game-canvas');

// ---- MAP LEVEL HELPERS ----
function getEnemyHpMult() { return Math.pow(1.08, state.mapLv - 1); }
function getMaxEnemies() { return Math.min(80, 12 + state.mapLv * 4); }
function getEliteRate() { return Math.min(0.5, 0.03 + state.mapLv * 0.01); }
function getScoreXpMult() { return Math.pow(1.06, state.mapLv - 1); }

// ---- AUDIO ----
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playHitSound(crit) {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = 'square';
  osc.frequency.value = crit ? 800 : 400;
  gain.gain.value = 0.08;
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (crit ? 0.15 : 0.08));
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + (crit ? 0.15 : 0.08));
}
function playKillSound() {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = 'sawtooth';
  osc.frequency.value = 200;
  osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
  gain.gain.value = 0.06;
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.2);
}

// ---- UTILITIES ----
function rand(min, max) { return Math.random() * (max - min) + min; }
function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
function pickWeighted(items, weights) {
  const total = weights.reduce((a, b) => a + b, 0);
  let r = Math.random() * total;
  for (let i = 0; i < items.length; i++) { r -= weights[i]; if (r <= 0) return items[i]; }
  return items[items.length - 1];
}
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

// ---- COMPUTED STATS ----
function getComputedStats() {
  let baseAtk = 0, baseSplash = 0, baseCd = Infinity;
  let coreCount = 0;
  for (const c of state.equipped.cores) {
    if (c) {
      baseAtk += c.atk;
      baseSplash = Math.max(baseSplash, c.splash);
      baseCd = Math.min(baseCd, c.cd);
      coreCount++;
    }
  }
  for (const s of state.equipped.subs) {
    if (s) {
      baseAtk += s.atk;
    }
  }

  if (coreCount === 0) return { atk: 0, splash: 30, cd: 1, critChance: 0, critDmg: 0, xpBonus: 0, dropBonus: 0, coreCount: 0 };

  let affixTotals = { flatAtk: 0, pctAtk: 0, flatSplash: 0, pctCd: 0, critChance: 0, critDmg: 0, xpBonus: 0, dropRate: 0 };
  const allEquipped = [...state.equipped.cores, ...state.equipped.subs, ...state.equipped.modules];
  for (const item of allEquipped) {
    if (!item || !item.affixes) continue;
    for (const af of item.affixes) {
      affixTotals[af.id] = (affixTotals[af.id] || 0) + af.value;
    }
  }

  let atk = (baseAtk + affixTotals.flatAtk) * (1 + affixTotals.pctAtk / 100);
  let splash = baseSplash + affixTotals.flatSplash;
  let cd = baseCd * (1 - affixTotals.pctCd / 100);
  cd = Math.max(0.05, cd);

  atk = atk * state.upgrades.atkMult;
  splash = splash * state.upgrades.splashMult;
  cd = cd * state.upgrades.cdMult;

  let critChance = (state.upgrades.critChance + affixTotals.critChance / 100);
  let critDmg = (state.upgrades.critMult + affixTotals.critDmg / 100);
  let xpBonus = affixTotals.xpBonus / 100;
  let dropBonus = affixTotals.dropRate / 100;

  return { atk: Math.floor(atk), splash: Math.floor(splash), cd: Math.round(cd * 100) / 100, critChance: Math.min(0.95, critChance), critDmg, xpBonus, dropBonus, coreCount };
}

// ---- ITEM GENERATION ----
function generateAffixes(ilv, count) {
  if (count === 0) return [];
  const affixes = [];
  const usedIds = new Set();
  for (let i = 0; i < count; i++) {
    const available = AFFIX_POOL.filter(a => !usedIds.has(a.id));
    if (available.length === 0) break;
    const pick = available[randInt(0, available.length - 1)];
    usedIds.add(pick.id);
    affixes.push({ id: pick.id, value: pick.gen(ilv), label: pick.label });
  }
  return affixes;
}

function makeItem(rarity, mapLv) {
  const roll = Math.random();
  const itemType = roll < 0.4 ? 'core' : roll < 0.7 ? 'sub' : 'module';
  const ilv = mapLv;
  const rarityIdx = RARITIES.indexOf(rarity);
  const affixCount = RARITY_AFFIX_COUNT[rarity];
  const affixes = generateAffixes(ilv, affixCount);
  const ilvScale = 1 + (ilv - 1) * 0.15;
  const isUnique = rarity === 'unique';
  const uniqueMult = isUnique ? 1.5 : 1;

  if (itemType === 'core') {
    const baseName = CORE_NAMES[randInt(0, CORE_NAMES.length - 1)];
    const attackShape = ATTACK_SHAPES[randInt(0, ATTACK_SHAPES.length - 1)];
    return {
      id: Date.now() + Math.random(),
      type: 'core',
      name: baseName,
      rarity, ilv,
      atk: Math.floor((8 + rarityIdx * 6 + randInt(0, 4)) * ilvScale * uniqueMult),
      splash: Math.floor((45 + rarityIdx * 15 + randInt(0, 10)) * (1 + (ilv - 1) * 0.05) * uniqueMult),
      cd: Math.round(Math.max(0.1, (0.6 - rarityIdx * 0.08 + rand(-0.05, 0.05)) / uniqueMult) * 100) / 100,
      affixes,
      attackShape,
    };
  } else if (itemType === 'sub') {
    const baseName = SUB_NAMES[randInt(0, SUB_NAMES.length - 1)];
    const autoMode = AUTO_MODES[randInt(0, AUTO_MODES.length - 1)];
    return {
      id: Date.now() + Math.random(),
      type: 'sub',
      name: baseName,
      rarity, ilv,
      atk: Math.floor((4 + rarityIdx * 4 + randInt(0, 3)) * ilvScale * uniqueMult),
      affixes,
      autoMode,
    };
  } else {
    const baseName = MODULE_NAMES[randInt(0, MODULE_NAMES.length - 1)];
    return {
      id: Date.now() + Math.random(),
      type: 'module',
      name: baseName,
      rarity, ilv,
      affixes,
    };
  }
}

// ---- ENEMY MANAGEMENT ----
function spawnEnemy() {
  if (!state.running) return;
  const isElite = Math.random() < getEliteRate();
  const template = isElite ? ELITE_TYPE : ENEMY_TYPES[randInt(0, ENEMY_TYPES.length - 1)];
  const scaledHp = Math.floor(template.baseHp * getEnemyHpMult());
  const w = window.innerWidth;
  const h = window.innerHeight;
  const side = randInt(0, 3);
  let x, y;
  const margin = 60;
  if (side === 0) { x = rand(margin, w - margin); y = CANVAS_PAD_TOP + margin; }
  else if (side === 1) { x = rand(margin, w - margin); y = h - CANVAS_PAD_BOT - margin; }
  else if (side === 2) { x = margin; y = rand(CANVAS_PAD_TOP + margin, h - CANVAS_PAD_BOT - margin); }
  else { x = w - margin; y = rand(CANVAS_PAD_TOP + margin, h - CANVAS_PAD_BOT - margin); }

  const enemy = {
    id: Date.now() + Math.random(),
    tag: template.tag,
    hp: scaledHp,
    maxHp: scaledHp,
    speed: template.speed + rand(-5, 5),
    credits: template.credits,
    score: template.score,
    elite: !!template.elite,
    x, y,
    el: null,
    vx: 0, vy: 0,
  };
  const angle = Math.random() * Math.PI * 2;
  enemy.vx = Math.cos(angle) * enemy.speed;
  enemy.vy = Math.sin(angle) * enemy.speed;

  const el = document.createElement('div');
  el.className = 'enemy' + (enemy.elite ? ' elite' : '');
  el.innerHTML = `<div class="hitbox"></div><div class="label">[${enemy.tag}:${enemy.hp}]</div><div class="hp-bar"><div class="hp-fill"></div></div>`;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  canvas.appendChild(el);
  enemy.el = el;
  enemy.labelEl = el.querySelector('.label');
  enemy.hpFillEl = el.querySelector('.hp-fill');
  state.enemies.push(enemy);
}

function removeEnemy(enemy) {
  if (enemy.el) enemy.el.remove();
  state.enemies = state.enemies.filter(e => e.id !== enemy.id);
}

function updateEnemies(dt) {
  const w = window.innerWidth;
  const h = window.innerHeight;
  for (const e of state.enemies) {
    const cx = w / 2, cy = h / 2;
    const pullDx = cx - e.x, pullDy = cy - e.y;
    const pullDist = Math.hypot(pullDx, pullDy) || 1;
    e.vx += (pullDx / pullDist) * 40 * dt;
    e.vy += (pullDy / pullDist) * 40 * dt;
    e.vx *= 0.97;
    e.vy *= 0.97;
    if (Math.random() < 0.02) {
      const angle = Math.random() * Math.PI * 2;
      e.vx += Math.cos(angle) * e.speed * 0.4;
      e.vy += Math.sin(angle) * e.speed * 0.4;
    }
    for (const other of state.enemies) {
      if (other.id === e.id) continue;
      const dx = e.x - other.x;
      const dy = e.y - other.y;
      const d = Math.hypot(dx, dy);
      if (d < 50 && d > 0) {
        e.vx += (dx / d) * (50 - d) * 0.2 * dt;
        e.vy += (dy / d) * (50 - d) * 0.2 * dt;
      }
    }
    const spd = Math.hypot(e.vx, e.vy);
    if (spd > e.speed * 1.5) {
      e.vx = (e.vx / spd) * e.speed * 1.5;
      e.vy = (e.vy / spd) * e.speed * 1.5;
    }
    e.x += e.vx * dt;
    e.y += e.vy * dt;
    let bounced = false;
    if (e.x < 10) { e.x = 10; bounced = true; }
    if (e.x > w - 10) { e.x = w - 10; bounced = true; }
    if (e.y < CANVAS_PAD_TOP + 10) { e.y = CANVAS_PAD_TOP + 10; bounced = true; }
    if (e.y > h - CANVAS_PAD_BOT - 10) { e.y = h - CANVAS_PAD_BOT - 10; bounced = true; }
    if (bounced) {
      const toCenterAngle = Math.atan2(cy - e.y, cx - e.x);
      const scatter = (Math.random() - 0.5) * Math.PI * 0.5;
      e.vx = Math.cos(toCenterAngle + scatter) * e.speed;
      e.vy = Math.sin(toCenterAngle + scatter) * e.speed;
    }
    e.el.style.left = e.x + 'px';
    e.el.style.top = e.y + 'px';
    e.labelEl.textContent = `[${e.tag}:${e.hp}]`;
    const hpPct = Math.max(0, e.hp / e.maxHp * 100);
    e.hpFillEl.style.width = hpPct + '%';
  }
}

// ---- ATTACK (with CORE shapes) ----
function getEnemyCenter(e) {
  return { x: e.x + 35, y: e.y + 10 };
}

function isInCircle(ex, ey, cx, cy, radius) {
  return dist(ex, ey, cx, cy) <= radius;
}

function isInLine(ex, ey, ox, oy, angle, width, length) {
  const dx = ex - ox, dy = ey - oy;
  const along = dx * Math.cos(angle) + dy * Math.sin(angle);
  const perp = Math.abs(-dx * Math.sin(angle) + dy * Math.cos(angle));
  return along >= 0 && along <= length && perp <= width / 2;
}

function isInCone(ex, ey, ox, oy, angle, halfAngle, radius) {
  const d = dist(ex, ey, ox, oy);
  if (d > radius) return false;
  const a = Math.atan2(ey - oy, ex - ox);
  let diff = a - angle;
  while (diff > Math.PI) diff -= Math.PI * 2;
  while (diff < -Math.PI) diff += Math.PI * 2;
  return Math.abs(diff) <= halfAngle;
}

function isInNova(ex, ey, cx, cy, innerR, outerR) {
  const d = dist(ex, ey, cx, cy);
  return d >= innerR && d <= outerR;
}

function attack(mx, my) {
  if (state.cooldown > 0 || state.paused) return;
  const stats = getComputedStats();
  if (stats.coreCount === 0) return;

  const playerX = window.innerWidth / 2;
  const playerY = window.innerHeight / 2;
  const clickAngle = Math.atan2(my - playerY, mx - playerX);

  // Each equipped CORE fires its own shape
  const toKill = new Set();
  const damaged = new Set();

  for (const core of state.equipped.cores) {
    if (!core) continue;
    const shape = core.attackShape || 'circle';
    const splash = Math.floor(core.splash * state.upgrades.splashMult);

    // Show effect
    showAttackEffect(mx, my, shape, splash, clickAngle, playerX, playerY);

    for (const e of state.enemies) {
      if (damaged.has(e.id)) continue; // only hit once per click per enemy across all cores
      const ec = getEnemyCenter(e);
      let hit = false;

      switch (shape) {
        case 'circle':
          hit = isInCircle(ec.x, ec.y, mx, my, splash);
          break;
        case 'line':
          hit = isInLine(ec.x, ec.y, mx, my, clickAngle, 30, splash * 3);
          break;
        case 'cone':
          hit = isInCone(ec.x, ec.y, mx, my, clickAngle, Math.PI / 6, splash * 1.5);
          break;
        case 'nova':
          hit = isInNova(ec.x, ec.y, playerX, playerY, splash * 0.5, splash * 2);
          break;
      }

      if (hit) {
        damaged.add(e.id);
        const isCrit = Math.random() < stats.critChance;
        const dmg = isCrit ? Math.floor(stats.atk * stats.critDmg) : stats.atk;
        e.hp -= dmg;
        showDamageNumber(e.x, e.y, dmg, isCrit);
        if (e.hp <= 0) toKill.add(e);
      }
    }
  }

  for (const e of toKill) killEnemy(e, false);
  state.cooldown = stats.cd;
}

function killEnemy(enemy, fromSub) {
  playKillSound();
  const mult = getScoreXpMult();
  const computed = getComputedStats();
  const creditMult = state.upgrades.creditMult * (1 + computed.xpBonus);
  state.score += Math.floor(enemy.score * mult);
  state.kills++;
  state.credits += Math.floor(enemy.credits * mult * creditMult);

  const baseDropChance = 0.15;
  const dropChance = baseDropChance * state.upgrades.dropMult * (1 + computed.dropBonus);
  if (Math.random() < dropChance || enemy.elite) {
    spawnDrop(enemy.x, enemy.y, enemy.elite);
  }

  // Check for explode subs
  if (!fromSub) {
    for (let i = 0; i < 4; i++) {
      const sub = state.equipped.subs[i];
      if (sub && sub.autoMode === 'explode') {
        // Queue explosion at enemy position
        state.pendingExplosions.push({ x: enemy.x, y: enemy.y, atk: sub.atk });
      }
    }
  }

  removeEnemy(enemy);
}

// ---- EFFECTS ----
function showAttackEffect(x, y, shape, splash, angle, px, py) {
  const el = document.createElement('div');
  el.className = 'attack-effect';
  switch (shape) {
    case 'circle': el.textContent = '*'; break;
    case 'line': el.textContent = '---'; break;
    case 'cone': el.textContent = '>>'; break;
    case 'nova': el.textContent = '(*)'; el.style.left = (px - 9) + 'px'; el.style.top = (py - 9) + 'px'; canvas.appendChild(el); setTimeout(() => el.remove(), 400); return;
  }
  el.style.left = (x - 9) + 'px';
  el.style.top = (y - 9) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 400);
}

function showDamageNumber(x, y, dmg, crit, isSub) {
  const el = document.createElement('div');
  el.className = 'damage-number' + (crit ? ' crit' : '') + (isSub ? ' sub-dmg' : '');
  el.textContent = (crit ? 'CRIT ' : '') + dmg;
  el.style.left = (x + rand(-15, 15)) + 'px';
  el.style.top = (y - 10) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 800);
  if (!isSub) playHitSound(crit);
}

function showSubEffect(x, y, symbol) {
  const el = document.createElement('div');
  el.className = 'sub-attack-effect';
  el.textContent = symbol;
  el.style.left = (x - 7) + 'px';
  el.style.top = (y - 7) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 400);
}

function showChainLine(x1, y1, x2, y2) {
  const el = document.createElement('div');
  el.className = 'chain-effect';
  const dx = x2 - x1, dy = y2 - y1;
  const len = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx);
  el.style.left = x1 + 'px';
  el.style.top = y1 + 'px';
  el.style.width = len + 'px';
  el.style.transform = `rotate(${angle}rad)`;
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 300);
}

// ---- SUB AUTO-ATTACK ----
function updateSubAttacks(dt) {
  if (state.paused || state.enemies.length === 0) return;
  const stats = getComputedStats();

  for (let i = 0; i < 4; i++) {
    state.subCooldowns[i] = Math.max(0, state.subCooldowns[i] - dt);
    const sub = state.equipped.subs[i];
    if (!sub) continue;

    // Orbit is continuous
    if (sub.autoMode === 'orbit') {
      state.orbitAngles[i] = (state.orbitAngles[i] || 0) + dt * 3;
      const ox = state.mouseX + Math.cos(state.orbitAngles[i]) * 150;
      const oy = state.mouseY + Math.sin(state.orbitAngles[i]) * 150;
      // Damage enemies near orbit point (every tick)
      const dps = sub.atk * 2; // DPS
      for (const e of state.enemies) {
        const ec = getEnemyCenter(e);
        if (dist(ec.x, ec.y, ox, oy) < 40) {
          const dmg = Math.max(1, Math.floor(dps * dt));
          e.hp -= dmg;
          if (Math.random() < 0.1) showDamageNumber(e.x, e.y, dmg, false, true);
          if (e.hp <= 0) {
            killEnemy(e, true);
            break;
          }
        }
      }
      continue;
    }

    if (state.subCooldowns[i] > 0) continue;

    const mx = state.mouseX, my = state.mouseY;
    // Find nearest enemy to cursor
    let nearest = null, nearDist = Infinity;
    for (const e of state.enemies) {
      const ec = getEnemyCenter(e);
      const d = dist(ec.x, ec.y, mx, my);
      if (d < nearDist) { nearDist = d; nearest = e; }
    }
    if (!nearest) continue;

    state.subCooldowns[i] = 1.5;

    switch (sub.autoMode) {
      case 'nearest': {
        const ec = getEnemyCenter(nearest);
        const isCrit = Math.random() < stats.critChance;
        const dmg = isCrit ? Math.floor(sub.atk * stats.critDmg) : sub.atk;
        nearest.hp -= dmg;
        showDamageNumber(nearest.x, nearest.y, dmg, isCrit, true);
        showSubEffect(ec.x, ec.y, 'âš¡');
        if (nearest.hp <= 0) killEnemy(nearest, true);
        break;
      }
      case 'chain': {
        let target = nearest;
        let chainDmg = sub.atk;
        const hit = new Set();
        for (let c = 0; c < 3 && target; c++) {
          const ec = getEnemyCenter(target);
          hit.add(target.id);
          const isCrit = Math.random() < stats.critChance;
          const dmg = isCrit ? Math.floor(chainDmg * stats.critDmg) : Math.floor(chainDmg);
          target.hp -= dmg;
          showDamageNumber(target.x, target.y, dmg, isCrit, true);
          showSubEffect(ec.x, ec.y, 'âš¡');

          const prevEc = ec;
          if (target.hp <= 0) { killEnemy(target, true); }

          // Find next chain target
          chainDmg *= 0.7;
          let nextTarget = null, nextDist = Infinity;
          for (const e of state.enemies) {
            if (hit.has(e.id)) continue;
            const eec = getEnemyCenter(e);
            const d = dist(eec.x, eec.y, prevEc.x, prevEc.y);
            if (d < 200 && d < nextDist) { nextDist = d; nextTarget = e; }
          }
          if (nextTarget) {
            const nec = getEnemyCenter(nextTarget);
            showChainLine(prevEc.x, prevEc.y, nec.x, nec.y);
          }
          target = nextTarget;
        }
        break;
      }
      case 'explode': {
        // Explode mode: just do a normal attack, explosion triggers on kill in killEnemy
        const ec = getEnemyCenter(nearest);
        const isCrit = Math.random() < stats.critChance;
        const dmg = isCrit ? Math.floor(sub.atk * stats.critDmg) : sub.atk;
        nearest.hp -= dmg;
        showDamageNumber(nearest.x, nearest.y, dmg, isCrit, true);
        showSubEffect(ec.x, ec.y, 'ðŸ’¥');
        if (nearest.hp <= 0) killEnemy(nearest, false); // false to allow explode
        break;
      }
    }
  }

  // Process pending explosions
  const explosions = state.pendingExplosions.splice(0);
  for (const exp of explosions) {
    const explosionDmg = Math.floor(exp.atk * 0.5);
    for (const e of [...state.enemies]) {
      const ec = getEnemyCenter(e);
      if (dist(ec.x, ec.y, exp.x + 35, exp.y + 10) < 120) {
        e.hp -= explosionDmg;
        showDamageNumber(e.x, e.y, explosionDmg, false, true);
        if (e.hp <= 0) killEnemy(e, true);
      }
    }
  }
}

// ---- DROPS ----
function getInvKeyForType(type) {
  if (type === 'core') return 'cores';
  if (type === 'sub') return 'subs';
  return 'modules';
}

function spawnDrop(x, y, guaranteed) {
  const rarity = guaranteed ? pickWeighted(RARITIES, [5, 15, 35, 30, 15, 1]) : pickWeighted(RARITIES, RARITY_WEIGHTS);
  const item = makeItem(rarity, state.mapLv);
  const invKey = getInvKeyForType(item.type);
  if (state.inventories[invKey].length >= MAX_INVENTORY) return;

  const drop = {
    id: item.id,
    x: x + rand(-20, 20),
    y: y + rand(-10, 10),
    item,
    ttl: 10,
    el: null,
  };

  const el = document.createElement('div');
  el.className = 'drop ' + rarity;
  const typeTag = item.type === 'core' ? 'C' : item.type === 'sub' ? 'S' : 'M';
  el.textContent = `[${typeTag}:iL${item.ilv} ${item.name}]`;
  el.style.left = drop.x + 'px';
  el.style.top = drop.y + 'px';
  el.addEventListener('click', (ev) => {
    ev.stopPropagation();
    pickupDrop(drop);
  });
  canvas.appendChild(el);
  drop.el = el;
  state.drops.push(drop);
}

function pickupDrop(drop) {
  const invKey = getInvKeyForType(drop.item.type);
  if (state.inventories[invKey].length >= MAX_INVENTORY) return;
  state.inventories[invKey].push(drop.item);
  if (drop.el) drop.el.remove();
  state.drops = state.drops.filter(d => d.id !== drop.id);
  renderInventory();
}

function updateDrops(dt) {
  for (const d of [...state.drops]) {
    d.ttl -= dt;
    if (d.ttl <= 0) {
      if (d.el) d.el.remove();
      state.drops = state.drops.filter(dd => dd.id !== d.id);
    } else if (d.ttl < 3) {
      if (d.el) d.el.style.opacity = d.ttl / 3;
    }
  }
}

// ---- EQUIP / UNEQUIP ----
function showBanner(text) {
  const banner = document.getElementById('status-banner');
  banner.textContent = text;
  banner.style.display = 'block';
  setTimeout(() => { banner.style.display = 'none'; }, 1500);
}

function getSlotsForType(type) {
  if (type === 'core') return state.equipped.cores;
  if (type === 'sub') return state.equipped.subs;
  return state.equipped.modules;
}

function equipItem(item) {
  const slots = getSlotsForType(item.type);
  const emptyIdx = slots.indexOf(null);
  if (emptyIdx === -1) {
    showBanner('NO EMPTY ' + item.type.toUpperCase() + ' SLOT');
    return;
  }
  slots[emptyIdx] = item;
  const invKey = getInvKeyForType(item.type);
  state.inventories[invKey] = state.inventories[invKey].filter(i => i.id !== item.id);
  renderInventory();
  updateHUD();
}

function unequipSlot(type, idx) {
  const slots = getSlotsForType(type);
  const item = slots[idx];
  if (!item) return;
  const invKey = getInvKeyForType(type);
  if (state.inventories[invKey].length >= MAX_INVENTORY) {
    showBanner('INVENTORY FULL');
    return;
  }
  slots[idx] = null;
  state.inventories[invKey].push(item);
  renderInventory();
  updateHUD();
}

function trashItem(item) {
  const invKey = getInvKeyForType(item.type);
  state.inventories[invKey] = state.inventories[invKey].filter(i => i.id !== item.id);
  renderInventory();
}

// ---- TOOLTIP ----
const tooltipEl = document.getElementById('item-tooltip');
function showTooltip(item, ev) {
  let html = `<div class="tt-name">${item.name}</div>`;
  html += `<div class="tt-type">${item.type.toUpperCase()} | iLv ${item.ilv} | ${item.rarity.toUpperCase()}</div>`;
  if (item.type === 'core') {
    html += `<div class="tt-stats">ATK: ${item.atk} | Splash: ${item.splash} | CD: ${item.cd}s</div>`;
    html += `<div class="tt-shape">Shape: ${(item.attackShape || 'circle').toUpperCase()}</div>`;
  } else if (item.type === 'sub') {
    html += `<div class="tt-stats">ATK: ${item.atk}</div>`;
    html += `<div class="tt-auto">Auto: ${(item.autoMode || 'nearest').toUpperCase()}</div>`;
  }
  if (item.affixes && item.affixes.length > 0) {
    html += '<div class="tt-affix">';
    for (const af of item.affixes) {
      html += af.label(af.value) + '<br>';
    }
    html += '</div>';
  }
  tooltipEl.innerHTML = html;
  tooltipEl.className = 'item-tooltip ' + item.rarity;
  tooltipEl.style.display = 'block';
  positionTooltip(ev);
}
function positionTooltip(ev) {
  let x = ev.clientX + 12;
  let y = ev.clientY + 12;
  if (x + 260 > window.innerWidth) x = ev.clientX - 260;
  if (y + 150 > window.innerHeight) y = ev.clientY - 150;
  tooltipEl.style.left = x + 'px';
  tooltipEl.style.top = y + 'px';
}
function hideTooltip() {
  tooltipEl.style.display = 'none';
}

// ---- RENDER INVENTORY ----
function renderInventory() {
  const coreContainer = document.getElementById('core-slots');
  const subContainer = document.getElementById('sub-slots');
  const modContainer = document.getElementById('module-slots');
  coreContainer.innerHTML = '';
  subContainer.innerHTML = '';
  modContainer.innerHTML = '';

  function renderSlots(container, slots, type, prefix) {
    for (let i = 0; i < 4; i++) {
      const item = slots[i];
      const slot = document.createElement('div');
      slot.className = 'equip-slot ' + (item ? item.rarity : 'empty');
      let extra = '';
      if (item && item.type === 'core' && item.attackShape) extra = ` [${item.attackShape[0].toUpperCase()}]`;
      if (item && item.type === 'sub' && item.autoMode) extra = ` [${item.autoMode[0].toUpperCase()}]`;
      slot.innerHTML = `<span class="slot-label">${prefix}${i+1}</span><span class="slot-item">${item ? '[iL' + item.ilv + '] ' + item.name + extra : 'â€” empty â€”'}</span>`;
      if (item) {
        slot.addEventListener('click', () => unequipSlot(type, i));
        slot.addEventListener('mouseenter', (ev) => showTooltip(item, ev));
        slot.addEventListener('mousemove', positionTooltip);
        slot.addEventListener('mouseleave', hideTooltip);
      }
      container.appendChild(slot);
    }
  }
  renderSlots(coreContainer, state.equipped.cores, 'core', 'C');
  renderSlots(subContainer, state.equipped.subs, 'sub', 'S');
  renderSlots(modContainer, state.equipped.modules, 'module', 'M');

  // Render each genre inventory with paging
  renderInvSection('core', state.inventories.cores, 'inv-list-core', 'inv-page-core', 'inv-count-core', 'cores');
  renderInvSection('sub', state.inventories.subs, 'inv-list-sub', 'inv-page-sub', 'inv-count-sub', 'subs');
  renderInvSection('module', state.inventories.modules, 'inv-list-mod', 'inv-page-mod', 'inv-count-mod', 'modules');
}

function renderInvSection(type, items, listId, pageId, countId, pageKey) {
  const container = document.getElementById(listId);
  const pageContainer = document.getElementById(pageId);
  document.getElementById(countId).textContent = items.length;
  container.innerHTML = '';
  pageContainer.innerHTML = '';

  const totalPages = Math.max(1, Math.ceil(items.length / INV_PAGE_SIZE));
  if (state.invPages[pageKey] >= totalPages) state.invPages[pageKey] = Math.max(0, totalPages - 1);
  const page = state.invPages[pageKey];
  const start = page * INV_PAGE_SIZE;
  const end = Math.min(start + INV_PAGE_SIZE, items.length);

  for (let i = start; i < end; i++) {
    const item = items[i];
    const row = document.createElement('div');
    row.className = 'inv-item ' + item.rarity;
    row.innerHTML = `<span class="inv-name">[iL${item.ilv}] ${item.name}</span><span class="inv-trash">âœ•</span>`;
    row.querySelector('.inv-name').addEventListener('click', (ev) => { ev.stopPropagation(); equipItem(item); });
    row.querySelector('.inv-trash').addEventListener('click', (ev) => { ev.stopPropagation(); trashItem(item); });
    row.addEventListener('mouseenter', (ev) => showTooltip(item, ev));
    row.addEventListener('mousemove', positionTooltip);
    row.addEventListener('mouseleave', hideTooltip);
    container.appendChild(row);
  }

  if (items.length > INV_PAGE_SIZE) {
    const prevBtn = document.createElement('button');
    prevBtn.className = 'inv-page-btn';
    prevBtn.textContent = '<';
    prevBtn.disabled = page === 0;
    prevBtn.addEventListener('click', (ev) => { ev.stopPropagation(); state.invPages[pageKey]--; renderInventory(); });
    prevBtn.addEventListener('mousedown', (ev) => ev.stopPropagation());

    const pageLabel = document.createElement('span');
    pageLabel.textContent = `${page + 1}/${totalPages}`;

    const nextBtn = document.createElement('button');
    nextBtn.className = 'inv-page-btn';
    nextBtn.textContent = '>';
    nextBtn.disabled = page >= totalPages - 1;
    nextBtn.addEventListener('click', (ev) => { ev.stopPropagation(); state.invPages[pageKey]++; renderInventory(); });
    nextBtn.addEventListener('mousedown', (ev) => ev.stopPropagation());

    pageContainer.appendChild(prevBtn);
    pageContainer.appendChild(pageLabel);
    pageContainer.appendChild(nextBtn);
  }
}

// ---- LEVEL UP ----
const SKILL_POOL = [
  { id: 'atk', name: 'ATK +20%', baseCost: 10, maxLv: 20, apply: () => { state.upgrades.atkMult += 0.2; } },
  { id: 'cd', name: 'CD -10%', baseCost: 10, maxLv: 15, apply: () => { state.upgrades.cdMult = Math.max(0.1, state.upgrades.cdMult * 0.9); } },
  { id: 'splash', name: 'Splash +20%', baseCost: 20, maxLv: 10, apply: () => { state.upgrades.splashMult += 0.2; } },
  { id: 'crit', name: 'Crit +10%', baseCost: 15, maxLv: 8, apply: () => { state.upgrades.critChance = Math.min(0.8, state.upgrades.critChance + 0.1); } },
  { id: 'critdmg', name: 'CritDMG +50%', baseCost: 25, maxLv: 10, apply: () => { state.upgrades.critMult += 0.5; } },
  { id: 'credits', name: 'Credits +15%', baseCost: 15, maxLv: 20, apply: () => { state.upgrades.creditMult += 0.15; } },
  { id: 'droprate', name: 'Drop +20%', baseCost: 30, maxLv: 10, apply: () => { state.upgrades.dropMult += 0.2; } },
];

function getSkillCost(skill) {
  const lv = state.skillLevels[skill.id] || 0;
  return Math.floor(skill.baseCost * Math.pow(1.3, lv));
}

function renderUpgradePanel() {
  const container = document.getElementById('upgrade-list');
  document.getElementById('hud-credits-panel').textContent = state.credits;
  container.innerHTML = '';
  for (const skill of SKILL_POOL) {
    const lv = state.skillLevels[skill.id] || 0;
    const cost = getSkillCost(skill);
    const canBuy = state.credits >= cost && lv < skill.maxLv;
    const row = document.createElement('div');
    row.className = 'upgrade-row';
    row.innerHTML = `<span>${skill.name} (${lv}/${skill.maxLv})</span>`;
    const btn = document.createElement('button');
    btn.className = 'upgrade-btn';
    btn.textContent = `[Â¢${cost}]`;
    btn.disabled = !canBuy;
    btn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const currentCost = getSkillCost(skill);
      if (state.credits >= currentCost && (state.skillLevels[skill.id] || 0) < skill.maxLv) {
        state.credits -= currentCost;
        state.skillLevels[skill.id] = (state.skillLevels[skill.id] || 0) + 1;
        skill.apply();
        renderUpgradePanel();
        updateHUD();
      }
    });
    row.appendChild(btn);
    container.appendChild(row);
  }
}

// ---- HUD ----
function updateHUD() {
  document.getElementById('maplv-select').value = state.mapLv;
  document.getElementById('hud-credits').textContent = state.credits;
  document.getElementById('hud-score').textContent = state.score;
  document.getElementById('hud-kills').textContent = state.kills;

  const stats = getComputedStats();
  document.getElementById('hud-cores').textContent = stats.coreCount;
  document.getElementById('hud-atk').textContent = stats.atk;
  document.getElementById('hud-splash').textContent = stats.splash;
  document.getElementById('hud-cd').textContent = stats.cd.toFixed(2);
  document.getElementById('hud-crit').textContent = Math.floor(stats.critChance * 100);
  document.getElementById('hud-critdmg').textContent = stats.critDmg.toFixed(1);
  updateCrosshair();
}

// ---- ORBIT RENDERING ----
let orbitMarkers = [null, null, null, null];
function updateOrbitVisuals() {
  for (let i = 0; i < 4; i++) {
    const sub = state.equipped.subs[i];
    if (sub && sub.autoMode === 'orbit') {
      if (!orbitMarkers[i]) {
        const m = document.createElement('div');
        m.className = 'orbit-marker';
        canvas.appendChild(m);
        orbitMarkers[i] = m;
      }
      const angle = state.orbitAngles[i] || 0;
      const ox = state.mouseX + Math.cos(angle) * 150;
      const oy = state.mouseY + Math.sin(angle) * 150;
      orbitMarkers[i].style.left = (ox - 4) + 'px';
      orbitMarkers[i].style.top = (oy - 4) + 'px';
    } else {
      if (orbitMarkers[i]) {
        orbitMarkers[i].remove();
        orbitMarkers[i] = null;
      }
    }
  }
}

// ---- MAIN LOOP ----
let lastTime = 0;
function gameLoop(timestamp) {
  if (!state.running) return;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;

  if (!state.paused) {
    if (state.cooldown > 0) state.cooldown = Math.max(0, state.cooldown - dt);

    if (mouseDown && state.cooldown <= 0) {
      if (state.mouseY >= CANVAS_PAD_TOP && state.mouseY <= window.innerHeight - CANVAS_PAD_BOT) {
        attack(state.mouseX, state.mouseY);
      }
    }

    state.spawnTimer += dt;
    if (state.spawnTimer >= SPAWN_INTERVAL && state.enemies.length < getMaxEnemies()) {
      state.spawnTimer = 0;
      spawnEnemy();
    }

    updateEnemies(dt);
    updateDrops(dt);
    updateSubAttacks(dt);
    updateOrbitVisuals();
  }

  updateHUD();
  requestAnimationFrame(gameLoop);
}

// ---- INPUT ----
let mouseDown = false;
const crosshairEl = document.getElementById('crosshair');
document.addEventListener('mousemove', (e) => {
  state.mouseX = e.clientX;
  state.mouseY = e.clientY;
  crosshairEl.style.left = e.clientX + 'px';
  crosshairEl.style.top = e.clientY + 'px';
});
function updateCrosshair() {
  const stats = getComputedStats();
  const size = stats.splash * 2;
  crosshairEl.style.width = size + 'px';
  crosshairEl.style.height = size + 'px';
}
document.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;
  mouseDown = true;
});
document.addEventListener('mouseup', (e) => {
  if (e.button === 0) mouseDown = false;
});

// Populate MapLv select (1-100)
const mapLvSelect = document.getElementById('maplv-select');
for (let i = 1; i <= 999; i++) {
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = i;
  mapLvSelect.appendChild(opt);
}
mapLvSelect.value = state.mapLv;
mapLvSelect.addEventListener('change', (ev) => {
  ev.stopPropagation();
  state.mapLv = parseInt(mapLvSelect.value);
  clearAllEnemies();
  const initial = Math.min(getMaxEnemies(), getMaxEnemies());
  for (let i = 0; i < initial; i++) spawnEnemy();
  updateHUD();
});
mapLvSelect.addEventListener('mousedown', (ev) => { ev.stopPropagation(); });

function clearAllEnemies() {
  for (const e of state.enemies) {
    if (e.el) e.el.remove();
  }
  state.enemies = [];
  // Also clear ground drops
  for (const d of state.drops) {
    if (d.el) d.el.remove();
  }
  state.drops = [];
}

// ---- START ----
// ---- SAVE / LOAD ----
const SAVE_KEY = 'hacksim_save';
const SAVE_VERSION = 1;

function saveGame() {
  const data = {
    version: SAVE_VERSION,
    mapLv: state.mapLv,
    score: state.score,
    kills: state.kills,
    credits: state.credits,
    equipped: state.equipped,
    inventories: state.inventories,
    upgrades: state.upgrades,
    skillLevels: state.skillLevels,
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(data));
}

function loadGame() {
  const raw = localStorage.getItem(SAVE_KEY);
  if (!raw) return false;
  try {
    const data = JSON.parse(raw);
    if (data.version !== SAVE_VERSION) return false;
    state.mapLv = data.mapLv || 1;
    state.score = data.score || 0;
    state.kills = data.kills || 0;
    state.credits = data.credits || 0;
    state.equipped = data.equipped || { cores: [null,null,null,null], subs: [null,null,null,null], modules: [null,null,null,null] };
    state.inventories = data.inventories || { cores: [], subs: [], modules: [] };
    state.upgrades = data.upgrades || state.upgrades;
    state.skillLevels = data.skillLevels || {};
    // Re-apply skill levels to upgrades
    return true;
  } catch (e) {
    return false;
  }
}

function resetGame() {
  localStorage.removeItem(SAVE_KEY);
  location.reload();
}

// Auto-save every 30 seconds
setInterval(saveGame, 30000);

function init() {
  const loaded = loadGame();
  if (!loaded) {
    state.equipped.cores[0] = {
      id: 0,
      type: 'core',
      name: 'Ping Flood',
      rarity: 'common',
      ilv: 1,
      atk: 10,
      splash: 50,
      cd: 0.5,
      affixes: [],
      attackShape: 'circle',
    };
  }
  state.running = true;
  lastTime = performance.now();
  const initial = Math.min(getMaxEnemies(), 12);
  for (let i = 0; i < initial; i++) spawnEnemy();
  renderUpgradePanel();
  renderInventory();
  updateHUD();
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
