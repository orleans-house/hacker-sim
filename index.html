<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HACK.SIM</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a0a;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  cursor: none;
  user-select: none;
}
#game-canvas {
  position: relative;
  width: 100vw;
  height: 100vh;
}

/* HUD */
#hud {
  position: fixed;
  top: 0; left: 0; right: 0;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(0,0,0,0.8);
  border-bottom: 1px solid #00ff41;
  z-index: 100;
  font-size: 14px;
}
.maplv-control {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
.maplv-btn {
  background: none;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 14px;
  width: 24px;
  height: 24px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  line-height: 1;
}
.maplv-btn:hover { background: rgba(0,255,65,0.2); }

/* Bottom HUD */
#bottom-hud {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  background: rgba(0,0,0,0.8);
  border-top: 1px solid #00ff41;
  z-index: 100;
  font-size: 13px;
}

/* Inventory panel (left side) */
#inventory-panel {
  position: fixed;
  top: 50px;
  left: 10px;
  width: 260px;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
  background: rgba(0,0,0,0.85);
  border: 1px solid #00ff41;
  padding: 8px;
  z-index: 100;
  font-size: 12px;
}
#inventory-panel h3 {
  color: #ffaa00;
  font-size: 13px;
  margin-bottom: 6px;
  text-align: center;
}
.equip-section { margin-bottom: 8px; }
.equip-section .section-title {
  color: #00ff41;
  font-size: 11px;
  margin-bottom: 4px;
  border-bottom: 1px solid #333;
  padding-bottom: 2px;
}
.equip-slot {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 2px 0;
  padding: 3px 4px;
  border: 1px solid #333;
  cursor: pointer;
  min-height: 22px;
}
.equip-slot:hover { border-color: #ffaa00; }
.equip-slot .slot-label { color: #555; font-size: 10px; margin-right: 4px; white-space: nowrap; }
.equip-slot .slot-item { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 11px; }
.equip-slot.empty .slot-item { color: #333; font-style: italic; }
.equip-slot.common { border-color: #aaa; background: rgba(170,170,170,0.05); }
.equip-slot.common .slot-item { color: #aaa; }
.equip-slot.uncommon { border-color: #00ff41; background: rgba(0,255,65,0.05); }
.equip-slot.uncommon .slot-item { color: #00ff41; }
.equip-slot.rare { border-color: #4488ff; background: rgba(68,136,255,0.05); }
.equip-slot.rare .slot-item { color: #4488ff; }
.equip-slot.epic { border-color: #aa44ff; background: rgba(170,68,255,0.05); }
.equip-slot.epic .slot-item { color: #aa44ff; }
.equip-slot.legendary { border-color: #ffaa00; background: rgba(255,170,0,0.08); }
.equip-slot.legendary .slot-item { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }

.inv-separator {
  border: none;
  border-top: 1px solid #333;
  margin: 6px 0;
}

.inv-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 2px 0;
  padding: 3px 4px;
  border: 1px solid transparent;
  cursor: pointer;
  position: relative;
}
.inv-item:hover { border-color: #00ff41; }
.inv-item .inv-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 11px; }
.inv-item .inv-type { font-size: 9px; color: #666; margin-left: 4px; white-space: nowrap; }
.inv-item .inv-trash {
  margin-left: 4px;
  color: #ff4444;
  cursor: pointer;
  font-size: 11px;
}
.inv-item .inv-trash:hover { color: #ff8888; }
.inv-item.common .inv-name { color: #aaa; }
.inv-item.uncommon .inv-name { color: #00ff41; }
.inv-item.rare .inv-name { color: #4488ff; }
.inv-item.epic .inv-name { color: #aa44ff; }
.inv-item.legendary .inv-name { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }

/* Tooltip */
.item-tooltip {
  position: fixed;
  background: rgba(0,0,0,0.95);
  border: 1px solid #00ff41;
  padding: 8px 10px;
  font-size: 11px;
  z-index: 500;
  pointer-events: none;
  max-width: 250px;
  line-height: 1.5;
  display: none;
}
.item-tooltip .tt-name { font-size: 13px; font-weight: bold; margin-bottom: 4px; }
.item-tooltip .tt-type { color: #888; font-size: 10px; }
.item-tooltip .tt-ilv { color: #888; font-size: 10px; }
.item-tooltip .tt-stats { margin: 4px 0; }
.item-tooltip .tt-affix { color: #00ccff; }
.item-tooltip.common .tt-name { color: #aaa; }
.item-tooltip.uncommon .tt-name { color: #00ff41; }
.item-tooltip.rare .tt-name { color: #4488ff; }
.item-tooltip.epic .tt-name { color: #aa44ff; }
.item-tooltip.legendary .tt-name { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }

/* Enemies */
.enemy {
  position: absolute;
  text-align: center;
  transition: opacity 0.2s;
  pointer-events: none;
}
.enemy .label {
  font-size: 14px;
  font-weight: bold;
  white-space: nowrap;
}
.enemy .hitbox {
  position: absolute;
  top: -4px;
  left: 50%;
  width: 20px;
  height: 20px;
  transform: translateX(-50%);
  border: 1px solid rgba(0,255,65,0.25);
  border-radius: 50%;
  pointer-events: none;
}
.enemy.elite .hitbox {
  border-color: rgba(255,170,0,0.3);
}
.enemy .hp-bar {
  width: 100%;
  height: 3px;
  background: #333;
  margin-top: 2px;
}
.enemy .hp-fill {
  height: 100%;
  background: #00ff41;
  transition: width 0.15s;
}
.enemy.elite .label { color: #ffaa00; }
.enemy.elite .hp-fill { background: #ffaa00; }

/* Attack effect */
.attack-effect {
  position: absolute;
  color: #00ff41;
  font-size: 18px;
  font-weight: bold;
  pointer-events: none;
  animation: attackPop 0.4s ease-out forwards;
  z-index: 50;
}
@keyframes attackPop {
  0% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(2); }
}

/* Damage numbers */
.damage-number {
  position: absolute;
  font-size: 16px;
  font-weight: bold;
  color: #ff4444;
  pointer-events: none;
  animation: floatUp 0.8s ease-out forwards;
  z-index: 50;
}
.damage-number.crit { font-size: 22px; color: #ffaa00; }
@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-40px); }
}

/* Drops */
.drop {
  position: absolute;
  font-size: 12px;
  padding: 2px 6px;
  border: 1px solid;
  cursor: pointer;
  animation: dropBounce 0.3s ease-out;
  z-index: 30;
}
.drop.common { color: #aaa; border-color: #aaa; }
.drop.uncommon { color: #00ff41; border-color: #00ff41; }
.drop.rare { color: #4488ff; border-color: #4488ff; }
.drop.epic { color: #aa44ff; border-color: #aa44ff; }
.drop.legendary { color: #ffaa00; border-color: #ffaa00; text-shadow: 0 0 8px #ffaa00; }
@keyframes dropBounce {
  0% { transform: translateY(-20px); opacity: 0; }
  100% { transform: translateY(0); opacity: 1; }
}

/* Upgrade panel (right side) */
#upgrade-panel {
  position: fixed;
  top: 50px;
  right: 10px;
  width: 220px;
  background: rgba(0,0,0,0.85);
  border: 1px solid #00ff41;
  padding: 8px;
  z-index: 100;
  font-size: 12px;
}
#upgrade-panel h3 {
  color: #ffaa00;
  font-size: 13px;
  margin-bottom: 6px;
  text-align: center;
}
.upgrade-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 3px 0;
  padding: 3px 4px;
}
.upgrade-btn {
  background: none;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  padding: 2px 8px;
  cursor: pointer;
  white-space: nowrap;
}
.upgrade-btn:hover { background: rgba(0,255,65,0.2); }
.upgrade-btn:disabled { color: #555; border-color: #555; cursor: default; }
.upgrade-btn:disabled:hover { background: none; }

/* Crosshair + splash range indicator */
#crosshair {
  position: fixed;
  border: 1px solid rgba(0,255,65,0.4);
  border-radius: 50%;
  pointer-events: none;
  z-index: 90;
  transform: translate(-50%, -50%);
}
#crosshair::after {
  content: '+';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #00ff41;
  font-size: 16px;
  font-weight: bold;
}

/* Status banner */
#status-banner {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 32px;
  color: #00ff41;
  z-index: 150;
  display: none;
  text-shadow: 0 0 20px #00ff41;
}
</style>
</head>
<body>

<div id="hud">
  <div>HACK.SIM</div>
  <div class="maplv-control">
    MapLv:<span id="hud-maplv">1</span>
    <button class="maplv-btn" id="maplv-down">▼</button>
    <button class="maplv-btn" id="maplv-up">▲</button>
  </div>
  <div>LV.<span id="hud-level">1</span> | XP: <span id="hud-xp">0</span>/<span id="hud-xp-max">10</span> | SP: <span id="hud-sp-top">0</span></div>
  <div>SCORE: <span id="hud-score">0</span></div>
</div>

<div id="bottom-hud">
  <div>CORES: <span id="hud-cores">1</span>/4</div>
  <div>ATK: <span id="hud-atk">10</span> | SPLASH: <span id="hud-splash">50</span> | CD: <span id="hud-cd">0.50</span>s</div>
  <div>CRIT: <span id="hud-crit">5</span>% x<span id="hud-critdmg">2.0</span></div>
  <div>KILLS: <span id="hud-kills">0</span></div>
</div>

<div id="inventory-panel">
  <h3>EQUIPMENT</h3>
  <div class="equip-section">
    <div class="section-title">── CORE SLOTS ──</div>
    <div id="core-slots"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">── MODULE SLOTS ──</div>
    <div id="module-slots"></div>
  </div>
  <hr class="inv-separator">
  <h3>INVENTORY [<span id="inv-count">0</span>/20]</h3>
  <div id="inv-list"></div>
</div>

<div id="game-canvas"></div>
<div id="crosshair"></div>

<div id="status-banner"></div>

<div id="upgrade-panel">
  <h3>UPGRADES [SP: <span id="hud-sp">0</span>]</h3>
  <div id="upgrade-list"></div>
</div>

<div class="item-tooltip" id="item-tooltip"></div>

<script>
// ---- CONFIG ----
const CANVAS_PAD_TOP = 40;
const CANVAS_PAD_BOT = 40;
const SPAWN_INTERVAL = 0.8;
const ENEMY_TYPES = [
  { tag: 'SRV', baseHp: 20, speed: 30, xp: 2, score: 10 },
  { tag: 'NODE', baseHp: 15, speed: 45, xp: 2, score: 10 },
  { tag: 'FW', baseHp: 50, speed: 20, xp: 5, score: 30 },
  { tag: 'DB', baseHp: 80, speed: 15, xp: 8, score: 50 },
  { tag: 'PROXY', baseHp: 30, speed: 55, xp: 3, score: 20 },
];
const ELITE_TYPE = { tag: 'MAINFRAME', baseHp: 300, speed: 10, xp: 30, score: 200, elite: true };
const RARITIES = ['common','uncommon','rare','epic','legendary'];
const RARITY_WEIGHTS = [50, 30, 14, 5, 1];
const RARITY_AFFIX_COUNT = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4 };
const CORE_NAMES = [
  'Ping Flood','Port Scanner','SQL Injector','Buffer Overflow',
  'Zero-Day Exploit','Rootkit Launcher','Worm Deployer','Trojan Horse',
  'DDoS Cannon','Crypto Breaker','Firewall Piercer','Kernel Panic'
];
const MODULE_NAMES = [
  'Logic Amplifier','Cache Optimizer','Thread Scheduler','Memory Allocator',
  'Pipeline Booster','Signal Enhancer','Packet Compressor','Clock Multiplier',
  'Branch Predictor','Entropy Filter','Hash Accelerator','Codec Overdriver'
];

// Affix definitions (traceRate removed)
const AFFIX_POOL = [
  { id: 'flatAtk',    label: (v) => `ATK +${v}`,           gen: (ilv) => randInt(2 + ilv, 5 + ilv * 2) },
  { id: 'pctAtk',     label: (v) => `ATK +${v}%`,          gen: (ilv) => randInt(3, 8 + ilv) },
  { id: 'flatSplash', label: (v) => `Splash +${v}`,        gen: (ilv) => randInt(5, 15 + ilv * 2) },
  { id: 'pctCd',      label: (v) => `CD -${v}%`,           gen: (ilv) => randInt(2, 6 + Math.floor(ilv / 2)) },
  { id: 'critChance', label: (v) => `CritChance +${v}%`,   gen: (ilv) => randInt(1, 4 + Math.floor(ilv / 3)) },
  { id: 'critDmg',    label: (v) => `CritDMG +${v}%`,      gen: (ilv) => randInt(5, 15 + ilv) },
  { id: 'xpBonus',    label: (v) => `XP +${v}%`,           gen: (ilv) => randInt(3, 8 + ilv) },
  { id: 'dropRate',   label: (v) => `DropRate +${v}%`,     gen: (ilv) => randInt(2, 5 + Math.floor(ilv / 2)) },
];

// ---- STATE ----
let state = {
  running: false,
  paused: false,
  mapLv: 1,
  spawnTimer: 0,
  score: 0,
  kills: 0,
  level: 1,
  xp: 0,
  xpToNext: 10,
  enemies: [],
  drops: [],
  equipped: {
    cores: [null, null, null, null],
    modules: [null, null, null, null],
  },
  cooldown: 0,
  mouseX: 0,
  mouseY: 0,
  upgrades: { atkMult: 1, rangeMult: 1, cdMult: 1, splashMult: 1, critChance: 0.05, critMult: 2, xpMult: 1, dropMult: 1 },
  sp: 0,
  skillLevels: {},
  inventory: [],
  maxInventory: 20,
};

const canvas = document.getElementById('game-canvas');

// ---- MAP LEVEL HELPERS ----
function getEnemyHpMult() { return 1 + (state.mapLv - 1) * 0.5; }
function getMaxEnemies() { return Math.min(40, 8 + state.mapLv * 2); }
function getEliteRate() { return Math.min(0.3, 0.03 + state.mapLv * 0.02); }
function getScoreXpMult() { return 1 + (state.mapLv - 1) * 0.3; }

// ---- UTILITIES ----
function rand(min, max) { return Math.random() * (max - min) + min; }
function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
function pickWeighted(items, weights) {
  const total = weights.reduce((a, b) => a + b, 0);
  let r = Math.random() * total;
  for (let i = 0; i < items.length; i++) { r -= weights[i]; if (r <= 0) return items[i]; }
  return items[items.length - 1];
}
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

// ---- COMPUTED STATS ----
function getComputedStats() {
  let baseAtk = 0, baseSplash = 0, baseCd = Infinity;
  let coreCount = 0;
  for (const c of state.equipped.cores) {
    if (c) {
      baseAtk += c.atk;
      baseSplash = Math.max(baseSplash, c.splash);
      baseCd = Math.min(baseCd, c.cd);
      coreCount++;
    }
  }
  if (coreCount === 0) return { atk: 0, splash: 30, cd: 1, critChance: 0, critDmg: 0, xpBonus: 0, dropBonus: 0, coreCount: 0 };

  let affixTotals = { flatAtk: 0, pctAtk: 0, flatSplash: 0, pctCd: 0, critChance: 0, critDmg: 0, xpBonus: 0, dropRate: 0 };
  const allEquipped = [...state.equipped.cores, ...state.equipped.modules];
  for (const item of allEquipped) {
    if (!item || !item.affixes) continue;
    for (const af of item.affixes) {
      affixTotals[af.id] = (affixTotals[af.id] || 0) + af.value;
    }
  }

  let atk = (baseAtk + affixTotals.flatAtk) * (1 + affixTotals.pctAtk / 100);
  let splash = baseSplash + affixTotals.flatSplash;
  let cd = baseCd * (1 - affixTotals.pctCd / 100);
  cd = Math.max(0.05, cd);

  atk = atk * state.upgrades.atkMult;
  splash = splash * state.upgrades.splashMult;
  cd = cd * state.upgrades.cdMult;

  let critChance = (state.upgrades.critChance + affixTotals.critChance / 100);
  let critDmg = (state.upgrades.critMult + affixTotals.critDmg / 100);
  let xpBonus = affixTotals.xpBonus / 100;
  let dropBonus = affixTotals.dropRate / 100;

  return { atk: Math.floor(atk), splash: Math.floor(splash), cd: Math.round(cd * 100) / 100, critChance: Math.min(0.95, critChance), critDmg, xpBonus, dropBonus, coreCount };
}

// ---- ITEM GENERATION ----
function generateAffixes(ilv, count) {
  if (count === 0) return [];
  const affixes = [];
  const usedIds = new Set();
  for (let i = 0; i < count; i++) {
    const available = AFFIX_POOL.filter(a => !usedIds.has(a.id));
    if (available.length === 0) break;
    const pick = available[randInt(0, available.length - 1)];
    usedIds.add(pick.id);
    affixes.push({ id: pick.id, value: pick.gen(ilv), label: pick.label });
  }
  return affixes;
}

function makeItem(rarity, mapLv) {
  const isCore = Math.random() < 0.6;
  const ilv = mapLv;
  const rarityIdx = RARITIES.indexOf(rarity);
  const affixCount = RARITY_AFFIX_COUNT[rarity];
  const affixes = generateAffixes(ilv, affixCount);

  if (isCore) {
    const baseName = CORE_NAMES[randInt(0, CORE_NAMES.length - 1)];
    const ilvScale = 1 + (ilv - 1) * 0.15;
    return {
      id: Date.now() + Math.random(),
      type: 'core',
      name: baseName,
      rarity,
      ilv,
      atk: Math.floor((8 + rarityIdx * 6 + randInt(0, 4)) * ilvScale),
      splash: Math.floor((45 + rarityIdx * 15 + randInt(0, 10)) * (1 + (ilv - 1) * 0.05)),
      cd: Math.round(Math.max(0.1, 0.6 - rarityIdx * 0.08 + rand(-0.05, 0.05)) * 100) / 100,
      affixes,
    };
  } else {
    const baseName = MODULE_NAMES[randInt(0, MODULE_NAMES.length - 1)];
    return {
      id: Date.now() + Math.random(),
      type: 'module',
      name: baseName,
      rarity,
      ilv,
      affixes,
    };
  }
}

// ---- ENEMY MANAGEMENT ----
function spawnEnemy() {
  if (!state.running) return;
  const isElite = Math.random() < getEliteRate();
  const template = isElite ? ELITE_TYPE : ENEMY_TYPES[randInt(0, ENEMY_TYPES.length - 1)];
  const scaledHp = Math.floor(template.baseHp * getEnemyHpMult());
  const w = window.innerWidth;
  const h = window.innerHeight;
  const side = randInt(0, 3);
  let x, y;
  const margin = 60;
  if (side === 0) { x = rand(margin, w - margin); y = CANVAS_PAD_TOP + margin; }
  else if (side === 1) { x = rand(margin, w - margin); y = h - CANVAS_PAD_BOT - margin; }
  else if (side === 2) { x = margin; y = rand(CANVAS_PAD_TOP + margin, h - CANVAS_PAD_BOT - margin); }
  else { x = w - margin; y = rand(CANVAS_PAD_TOP + margin, h - CANVAS_PAD_BOT - margin); }

  const enemy = {
    id: Date.now() + Math.random(),
    tag: template.tag,
    hp: scaledHp,
    maxHp: scaledHp,
    speed: template.speed + rand(-5, 5),
    xp: template.xp,
    score: template.score,
    elite: !!template.elite,
    x, y,
    el: null,
    vx: 0, vy: 0,
  };
  const angle = Math.random() * Math.PI * 2;
  enemy.vx = Math.cos(angle) * enemy.speed;
  enemy.vy = Math.sin(angle) * enemy.speed;

  const el = document.createElement('div');
  el.className = 'enemy' + (enemy.elite ? ' elite' : '');
  el.innerHTML = `<div class="hitbox"></div><div class="label">[${enemy.tag}:${enemy.hp}]</div><div class="hp-bar"><div class="hp-fill"></div></div>`;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  canvas.appendChild(el);
  enemy.el = el;
  enemy.labelEl = el.querySelector('.label');
  enemy.hpFillEl = el.querySelector('.hp-fill');
  state.enemies.push(enemy);
}

function removeEnemy(enemy) {
  if (enemy.el) enemy.el.remove();
  state.enemies = state.enemies.filter(e => e.id !== enemy.id);
}

function updateEnemies(dt) {
  const w = window.innerWidth;
  const h = window.innerHeight;
  for (const e of state.enemies) {
    // Constant center pull (strong enough to overcome edge drift)
    const cx = w / 2, cy = h / 2;
    const pullDx = cx - e.x, pullDy = cy - e.y;
    const pullDist = Math.hypot(pullDx, pullDy) || 1;
    e.vx += (pullDx / pullDist) * 40 * dt;
    e.vy += (pullDy / pullDist) * 40 * dt;
    // Velocity damping
    e.vx *= 0.97;
    e.vy *= 0.97;
    // Random nudge for organic movement
    if (Math.random() < 0.02) {
      const angle = Math.random() * Math.PI * 2;
      e.vx += Math.cos(angle) * e.speed * 0.4;
      e.vy += Math.sin(angle) * e.speed * 0.4;
    }
    // Gentle repulsion from nearby enemies
    for (const other of state.enemies) {
      if (other.id === e.id) continue;
      const dx = e.x - other.x;
      const dy = e.y - other.y;
      const d = Math.hypot(dx, dy);
      if (d < 50 && d > 0) {
        e.vx += (dx / d) * (50 - d) * 0.2 * dt;
        e.vy += (dy / d) * (50 - d) * 0.2 * dt;
      }
    }
    // Clamp speed
    const spd = Math.hypot(e.vx, e.vy);
    if (spd > e.speed * 1.5) {
      e.vx = (e.vx / spd) * e.speed * 1.5;
      e.vy = (e.vy / spd) * e.speed * 1.5;
    }
    e.x += e.vx * dt;
    e.y += e.vy * dt;
    // Bounce off edges — redirect toward center
    let bounced = false;
    if (e.x < 10) { e.x = 10; bounced = true; }
    if (e.x > w - 10) { e.x = w - 10; bounced = true; }
    if (e.y < CANVAS_PAD_TOP + 10) { e.y = CANVAS_PAD_TOP + 10; bounced = true; }
    if (e.y > h - CANVAS_PAD_BOT - 10) { e.y = h - CANVAS_PAD_BOT - 10; bounced = true; }
    if (bounced) {
      const toCenterAngle = Math.atan2(cy - e.y, cx - e.x);
      const scatter = (Math.random() - 0.5) * Math.PI * 0.5;
      e.vx = Math.cos(toCenterAngle + scatter) * e.speed;
      e.vy = Math.sin(toCenterAngle + scatter) * e.speed;
    }
    e.el.style.left = e.x + 'px';
    e.el.style.top = e.y + 'px';
    e.labelEl.textContent = `[${e.tag}:${e.hp}]`;
    const hpPct = Math.max(0, e.hp / e.maxHp * 100);
    e.hpFillEl.style.width = hpPct + '%';
  }
}

// ---- ATTACK ----
function attack(mx, my) {
  if (state.cooldown > 0 || state.paused) return;
  const stats = getComputedStats();
  if (stats.coreCount === 0) return;

  showAttackEffect(mx, my);

  const toKill = [];
  for (const e of state.enemies) {
    const ex = e.x + 35;
    const ey = e.y + 10;
    const d = dist(mx, my, ex, ey);
    if (d <= stats.splash) {
      const isCrit = Math.random() < stats.critChance;
      const dmg = isCrit ? Math.floor(stats.atk * stats.critDmg) : stats.atk;
      e.hp -= dmg;
      showDamageNumber(e.x, e.y, dmg, isCrit);
      if (e.hp <= 0) toKill.push(e);
    }
  }
  for (const e of toKill) killEnemy(e);

  state.cooldown = stats.cd;
}

function killEnemy(enemy) {
  const mult = getScoreXpMult();
  const computed = getComputedStats();
  const xpMult = state.upgrades.xpMult * (1 + computed.xpBonus);
  state.score += Math.floor(enemy.score * mult);
  state.kills++;
  state.xp += Math.floor(enemy.xp * mult * xpMult);

  const baseDropChance = 0.15;
  const dropChance = baseDropChance * state.upgrades.dropMult * (1 + computed.dropBonus);
  if (Math.random() < dropChance || enemy.elite) {
    spawnDrop(enemy.x, enemy.y, enemy.elite);
  }
  removeEnemy(enemy);
  checkLevelUp();
}

// ---- EFFECTS ----
function showAttackEffect(x, y) {
  const el = document.createElement('div');
  el.className = 'attack-effect';
  el.textContent = '×';
  el.style.left = (x - 9) + 'px';
  el.style.top = (y - 9) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 400);
}

function showDamageNumber(x, y, dmg, crit) {
  const el = document.createElement('div');
  el.className = 'damage-number' + (crit ? ' crit' : '');
  el.textContent = (crit ? 'CRIT ' : '-') + dmg;
  el.style.left = (x + rand(-15, 15)) + 'px';
  el.style.top = (y - 10) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 800);
}

// ---- DROPS ----
function spawnDrop(x, y, guaranteed) {
  if (state.inventory.length >= state.maxInventory) return;
  const rarity = guaranteed ? pickWeighted(RARITIES, [5, 15, 35, 30, 15]) : pickWeighted(RARITIES, RARITY_WEIGHTS);
  const item = makeItem(rarity, state.mapLv);

  const drop = {
    id: item.id,
    x: x + rand(-20, 20),
    y: y + rand(-10, 10),
    item,
    ttl: 10,
    el: null,
  };

  const el = document.createElement('div');
  el.className = 'drop ' + rarity;
  const typeTag = item.type === 'core' ? 'C' : 'M';
  el.textContent = `[${typeTag}:${item.name}]`;
  el.style.left = drop.x + 'px';
  el.style.top = drop.y + 'px';
  el.addEventListener('click', (ev) => {
    ev.stopPropagation();
    pickupDrop(drop);
  });
  canvas.appendChild(el);
  drop.el = el;
  state.drops.push(drop);
}

function pickupDrop(drop) {
  if (state.inventory.length >= state.maxInventory) return;
  state.inventory.push(drop.item);
  if (drop.el) drop.el.remove();
  state.drops = state.drops.filter(d => d.id !== drop.id);
  renderInventory();
}

function updateDrops(dt) {
  for (const d of [...state.drops]) {
    d.ttl -= dt;
    if (d.ttl <= 0) {
      if (d.el) d.el.remove();
      state.drops = state.drops.filter(dd => dd.id !== d.id);
    } else if (d.ttl < 3) {
      if (d.el) d.el.style.opacity = d.ttl / 3;
    }
  }
}

// ---- EQUIP / UNEQUIP ----
function showBanner(text) {
  const banner = document.getElementById('status-banner');
  banner.textContent = text;
  banner.style.display = 'block';
  setTimeout(() => { banner.style.display = 'none'; }, 1500);
}

function equipItem(item) {
  const slots = item.type === 'core' ? state.equipped.cores : state.equipped.modules;
  const emptyIdx = slots.indexOf(null);
  if (emptyIdx === -1) {
    showBanner('NO EMPTY ' + item.type.toUpperCase() + ' SLOT');
    return;
  }
  slots[emptyIdx] = item;
  state.inventory = state.inventory.filter(i => i.id !== item.id);
  renderInventory();
  updateHUD();
}

function unequipSlot(type, idx) {
  const slots = type === 'core' ? state.equipped.cores : state.equipped.modules;
  const item = slots[idx];
  if (!item) return;
  if (state.inventory.length >= state.maxInventory) {
    showBanner('INVENTORY FULL');
    return;
  }
  slots[idx] = null;
  state.inventory.push(item);
  renderInventory();
  updateHUD();
}

function trashItem(item) {
  state.inventory = state.inventory.filter(i => i.id !== item.id);
  renderInventory();
}

// ---- TOOLTIP ----
const tooltipEl = document.getElementById('item-tooltip');
function showTooltip(item, ev) {
  let html = `<div class="tt-name">${item.name}</div>`;
  html += `<div class="tt-type">${item.type.toUpperCase()} | iLv ${item.ilv} | ${item.rarity.toUpperCase()}</div>`;
  if (item.type === 'core') {
    html += `<div class="tt-stats">ATK: ${item.atk} | Splash: ${item.splash} | CD: ${item.cd}s</div>`;
  }
  if (item.affixes && item.affixes.length > 0) {
    html += '<div class="tt-affix">';
    for (const af of item.affixes) {
      html += af.label(af.value) + '<br>';
    }
    html += '</div>';
  }
  tooltipEl.innerHTML = html;
  tooltipEl.className = 'item-tooltip ' + item.rarity;
  tooltipEl.style.display = 'block';
  positionTooltip(ev);
}
function positionTooltip(ev) {
  let x = ev.clientX + 12;
  let y = ev.clientY + 12;
  if (x + 260 > window.innerWidth) x = ev.clientX - 260;
  if (y + 150 > window.innerHeight) y = ev.clientY - 150;
  tooltipEl.style.left = x + 'px';
  tooltipEl.style.top = y + 'px';
}
function hideTooltip() {
  tooltipEl.style.display = 'none';
}

// ---- RENDER INVENTORY ----
function renderInventory() {
  const coreContainer = document.getElementById('core-slots');
  const modContainer = document.getElementById('module-slots');
  coreContainer.innerHTML = '';
  modContainer.innerHTML = '';

  for (let i = 0; i < 4; i++) {
    const item = state.equipped.cores[i];
    const slot = document.createElement('div');
    slot.className = 'equip-slot ' + (item ? 'filled ' + item.rarity : 'empty');
    slot.innerHTML = `<span class="slot-label">C${i+1}</span><span class="slot-item">${item ? item.name : '— empty —'}</span>`;
    if (item) {
      slot.addEventListener('click', () => unequipSlot('core', i));
      slot.addEventListener('mouseenter', (ev) => showTooltip(item, ev));
      slot.addEventListener('mousemove', positionTooltip);
      slot.addEventListener('mouseleave', hideTooltip);
    }
    coreContainer.appendChild(slot);
  }

  for (let i = 0; i < 4; i++) {
    const item = state.equipped.modules[i];
    const slot = document.createElement('div');
    slot.className = 'equip-slot ' + (item ? 'filled ' + item.rarity : 'empty');
    slot.innerHTML = `<span class="slot-label">M${i+1}</span><span class="slot-item">${item ? item.name : '— empty —'}</span>`;
    if (item) {
      slot.addEventListener('click', () => unequipSlot('module', i));
      slot.addEventListener('mouseenter', (ev) => showTooltip(item, ev));
      slot.addEventListener('mousemove', positionTooltip);
      slot.addEventListener('mouseleave', hideTooltip);
    }
    modContainer.appendChild(slot);
  }

  const container = document.getElementById('inv-list');
  document.getElementById('inv-count').textContent = state.inventory.length;
  container.innerHTML = '';
  for (const item of state.inventory) {
    const row = document.createElement('div');
    row.className = 'inv-item ' + item.rarity;
    const typeTag = item.type === 'core' ? 'CORE' : 'MOD';
    row.innerHTML = `<span class="inv-name">${item.name}</span><span class="inv-type">${typeTag}</span><span class="inv-trash">✕</span>`;
    row.querySelector('.inv-name').addEventListener('click', (ev) => { ev.stopPropagation(); equipItem(item); });
    row.querySelector('.inv-trash').addEventListener('click', (ev) => { ev.stopPropagation(); trashItem(item); });
    row.addEventListener('mouseenter', (ev) => showTooltip(item, ev));
    row.addEventListener('mousemove', positionTooltip);
    row.addEventListener('mouseleave', hideTooltip);
    container.appendChild(row);
  }
}

// ---- LEVEL UP (Skill Point System) ----
function checkLevelUp() {
  while (state.xp >= state.xpToNext) {
    state.xp -= state.xpToNext;
    state.level++;
    state.sp++;
    state.xpToNext = Math.floor(state.xpToNext * 1.5);
  }
  renderUpgradePanel();
}

const SKILL_POOL = [
  { id: 'atk', name: 'ATK +20%', cost: 1, maxLv: 10, apply: () => { state.upgrades.atkMult += 0.2; } },
  { id: 'cd', name: 'CD -10%', cost: 1, maxLv: 8, apply: () => { state.upgrades.cdMult = Math.max(0.1, state.upgrades.cdMult * 0.9); } },
  { id: 'splash', name: 'Splash +20%', cost: 2, maxLv: 5, apply: () => { state.upgrades.splashMult += 0.2; } },
  { id: 'crit', name: 'Crit +10%', cost: 1, maxLv: 6, apply: () => { state.upgrades.critChance = Math.min(0.8, state.upgrades.critChance + 0.1); } },
  { id: 'critdmg', name: 'CritDMG +50%', cost: 2, maxLv: 5, apply: () => { state.upgrades.critMult += 0.5; } },
  { id: 'xpbonus', name: 'XP +15%', cost: 1, maxLv: 10, apply: () => { state.upgrades.xpMult += 0.15; } },
  { id: 'droprate', name: 'Drop +20%', cost: 2, maxLv: 5, apply: () => { state.upgrades.dropMult += 0.2; } },
];

function renderUpgradePanel() {
  const container = document.getElementById('upgrade-list');
  const spEl = document.getElementById('hud-sp');
  spEl.textContent = state.sp;
  container.innerHTML = '';
  for (const skill of SKILL_POOL) {
    const lv = state.skillLevels[skill.id] || 0;
    const canBuy = state.sp >= skill.cost && lv < skill.maxLv;
    const row = document.createElement('div');
    row.className = 'upgrade-row';
    row.innerHTML = `<span>${skill.name} (${lv}/${skill.maxLv})</span>`;
    const btn = document.createElement('button');
    btn.className = 'upgrade-btn';
    btn.textContent = `[${skill.cost}SP]`;
    btn.disabled = !canBuy;
    btn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (state.sp >= skill.cost && (state.skillLevels[skill.id] || 0) < skill.maxLv) {
        state.sp -= skill.cost;
        state.skillLevels[skill.id] = (state.skillLevels[skill.id] || 0) + 1;
        skill.apply();
        renderUpgradePanel();
        updateHUD();
      }
    });
    row.appendChild(btn);
    container.appendChild(row);
  }
}

// ---- HUD ----
function updateHUD() {
  document.getElementById('hud-maplv').textContent = state.mapLv;
  document.getElementById('hud-level').textContent = state.level;
  document.getElementById('hud-xp').textContent = state.xp;
  document.getElementById('hud-xp-max').textContent = state.xpToNext;
  document.getElementById('hud-score').textContent = state.score;
  document.getElementById('hud-kills').textContent = state.kills;
  document.getElementById('hud-sp-top').textContent = state.sp;

  const stats = getComputedStats();
  document.getElementById('hud-cores').textContent = stats.coreCount;
  document.getElementById('hud-atk').textContent = stats.atk;
  document.getElementById('hud-splash').textContent = stats.splash;
  document.getElementById('hud-cd').textContent = stats.cd.toFixed(2);
  document.getElementById('hud-crit').textContent = Math.floor(stats.critChance * 100);
  document.getElementById('hud-critdmg').textContent = stats.critDmg.toFixed(1);
  updateCrosshair();
}

// ---- MAIN LOOP ----
let lastTime = 0;
function gameLoop(timestamp) {
  if (!state.running) return;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;

  if (!state.paused) {
    // Cooldown
    if (state.cooldown > 0) state.cooldown = Math.max(0, state.cooldown - dt);

    // Auto-attack while holding mouse
    if (mouseDown && state.cooldown <= 0) {
      if (state.mouseY >= CANVAS_PAD_TOP && state.mouseY <= window.innerHeight - CANVAS_PAD_BOT) {
        attack(state.mouseX, state.mouseY);
      }
    }

    // Continuous spawn
    state.spawnTimer += dt;
    if (state.spawnTimer >= SPAWN_INTERVAL && state.enemies.length < getMaxEnemies()) {
      state.spawnTimer = 0;
      spawnEnemy();
    }

    updateEnemies(dt);
    updateDrops(dt);
  }

  updateHUD();
  requestAnimationFrame(gameLoop);
}

// ---- INPUT ----
let mouseDown = false;
const crosshairEl = document.getElementById('crosshair');
document.addEventListener('mousemove', (e) => {
  state.mouseX = e.clientX;
  state.mouseY = e.clientY;
  crosshairEl.style.left = e.clientX + 'px';
  crosshairEl.style.top = e.clientY + 'px';
});
function updateCrosshair() {
  const stats = getComputedStats();
  const size = stats.splash * 2;
  crosshairEl.style.width = size + 'px';
  crosshairEl.style.height = size + 'px';
}
document.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;
  mouseDown = true;
});
document.addEventListener('mouseup', (e) => {
  if (e.button === 0) mouseDown = false;
});

// MapLv buttons
document.getElementById('maplv-up').addEventListener('click', (ev) => {
  ev.stopPropagation();
  state.mapLv++;
  updateHUD();
});
document.getElementById('maplv-down').addEventListener('click', (ev) => {
  ev.stopPropagation();
  if (state.mapLv > 1) state.mapLv--;
  updateHUD();
});
// Prevent attacks when clicking MapLv buttons
document.getElementById('maplv-up').addEventListener('mousedown', (ev) => { ev.stopPropagation(); });
document.getElementById('maplv-down').addEventListener('mousedown', (ev) => { ev.stopPropagation(); });

// ---- START ----
function init() {
  state.equipped.cores[0] = {
    id: 0,
    type: 'core',
    name: 'Ping Flood',
    rarity: 'common',
    ilv: 1,
    atk: 10,
    splash: 50,
    cd: 0.5,
    affixes: [],
  };
  state.running = true;
  lastTime = performance.now();
  // Spawn initial enemies
  const initial = Math.min(getMaxEnemies(), 5);
  for (let i = 0; i < initial; i++) spawnEnemy();
  renderUpgradePanel();
  renderInventory();
  updateHUD();
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
