<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HACK.SIM</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a0a;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  cursor: none;
  user-select: none;
}
#game-canvas {
  position: relative;
  width: 100vw;
  height: 100vh;
}

/* HUD */
#hud {
  position: fixed;
  top: 0; left: 0; right: 0;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(0,0,0,0.8);
  border-bottom: 1px solid #00ff41;
  z-index: 100;
  font-size: 14px;
}
.maplv-control {
  display: inline-flex;
  align-items: center;
  gap: 4px;
}
#maplv-select {
  background: #0a0a0a;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 13px;
  padding: 2px 4px;
  cursor: pointer;
}

/* Bottom HUD */
#bottom-hud {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  background: rgba(0,0,0,0.8);
  border-top: 1px solid #00ff41;
  z-index: 100;
  font-size: 13px;
}

/* Inventory panel (left side) */
#inventory-panel {
  position: fixed;
  top: 50px;
  left: 10px;
  width: 260px;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
  background: rgba(0,0,0,0.85);
  border: 1px solid #00ff41;
  padding: 8px;
  z-index: 100;
  font-size: 12px;
}
#inventory-panel::-webkit-scrollbar { width: 6px; }
#inventory-panel::-webkit-scrollbar-track { background: #111; }
#inventory-panel::-webkit-scrollbar-thumb { background: #00ff41; }
#inventory-panel h3 {
  color: #ffaa00;
  font-size: 13px;
  margin-bottom: 6px;
  text-align: center;
}
.equip-section { margin-bottom: 8px; }
.equip-section .section-title {
  color: #00ff41;
  font-size: 11px;
  margin-bottom: 4px;
  border-bottom: 1px solid #333;
  padding-bottom: 2px;
}
.equip-slot {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 2px 0;
  padding: 3px 4px;
  border: 1px solid #333;
  cursor: pointer;
  min-height: 22px;
}
.equip-slot:hover { border-color: #ffaa00; }
.equip-slot .slot-label { color: #555; font-size: 10px; margin-right: 4px; white-space: nowrap; }
.equip-slot .slot-item { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 11px; }
.equip-slot.empty .slot-item { color: #333; font-style: italic; }
.equip-slot.common { border-color: #aaa; background: rgba(170,170,170,0.05); }
.equip-slot.common .slot-item { color: #aaa; }
.equip-slot.uncommon { border-color: #00ff41; background: rgba(0,255,65,0.05); }
.equip-slot.uncommon .slot-item { color: #00ff41; }
.equip-slot.rare { border-color: #4488ff; background: rgba(68,136,255,0.05); }
.equip-slot.rare .slot-item { color: #4488ff; }
.equip-slot.epic { border-color: #aa44ff; background: rgba(170,68,255,0.05); }
.equip-slot.epic .slot-item { color: #aa44ff; }
.equip-slot.legendary { border-color: #ffaa00; background: rgba(255,170,0,0.08); }
.equip-slot.legendary .slot-item { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }
.equip-slot.unique { border-color: #ff2222; background: rgba(255,34,34,0.08); }
.equip-slot.unique .slot-item { color: #ff2222; text-shadow: 0 0 8px #ff2222; }

.inv-separator {
  border: none;
  border-top: 1px solid #333;
  margin: 6px 0;
}

.inv-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 2px 0;
  padding: 3px 4px;
  border: 1px solid transparent;
  cursor: pointer;
  position: relative;
}
.inv-item:hover { border-color: #00ff41; }
.inv-item .inv-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 11px; }
.inv-item .inv-type { font-size: 9px; color: #666; margin-left: 4px; white-space: nowrap; }
.inv-item .inv-trash {
  margin-left: 4px;
  color: #ff4444;
  cursor: pointer;
  font-size: 11px;
}
.inv-item .inv-trash:hover { color: #ff8888; }
.inv-item.common .inv-name { color: #aaa; }
.inv-item.uncommon .inv-name { color: #00ff41; }
.inv-item.rare .inv-name { color: #4488ff; }
.inv-item.epic .inv-name { color: #aa44ff; }
.inv-item.legendary .inv-name { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }
.inv-item.unique .inv-name { color: #ff2222; text-shadow: 0 0 8px #ff2222; }

.inv-page-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 6px;
  margin-top: 4px;
  font-size: 10px;
  color: #888;
}
.inv-page-btn {
  background: none;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  padding: 1px 6px;
  cursor: pointer;
}
.inv-page-btn:hover { background: rgba(0,255,65,0.2); }
.inv-page-btn:disabled { color: #555; border-color: #555; cursor: default; }
.inv-page-btn:disabled:hover { background: none; }

/* Tooltip */
.item-tooltip {
  position: fixed;
  background: rgba(0,0,0,0.95);
  border: 1px solid #00ff41;
  padding: 8px 10px;
  font-size: 11px;
  z-index: 500;
  pointer-events: none;
  max-width: 250px;
  line-height: 1.5;
  display: none;
}
.item-tooltip .tt-name { font-size: 13px; font-weight: bold; margin-bottom: 4px; }
.item-tooltip .tt-type { color: #888; font-size: 10px; }
.item-tooltip .tt-ilv { color: #888; font-size: 10px; }
.item-tooltip .tt-stats { margin: 4px 0; }
.item-tooltip .tt-affix { color: #00ccff; }
.item-tooltip .tt-shape { color: #ffcc00; font-size: 10px; }
.item-tooltip .tt-auto { color: #ff66aa; font-size: 10px; }
.item-tooltip.common .tt-name { color: #aaa; }
.item-tooltip.uncommon .tt-name { color: #00ff41; }
.item-tooltip.rare .tt-name { color: #4488ff; }
.item-tooltip.epic .tt-name { color: #aa44ff; }
.item-tooltip.legendary .tt-name { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }
.item-tooltip.unique .tt-name { color: #ff2222; text-shadow: 0 0 8px #ff2222; }

/* Enemies */
.enemy {
  position: absolute;
  text-align: center;
  transition: opacity 0.2s;
  pointer-events: none;
}
.enemy .label {
  font-size: 14px;
  font-weight: bold;
  white-space: nowrap;
}
.enemy .hitbox {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 10px;
  height: 10px;
  transform: translate(-50%, -50%);
  border: 1px solid rgba(0,255,65,0.25);
  border-radius: 50%;
  pointer-events: none;
}
.enemy.elite .hitbox {
  border-color: rgba(255,170,0,0.3);
}
.enemy .hp-bar {
  width: 100%;
  height: 3px;
  background: #333;
  margin-top: 2px;
}
.enemy .hp-fill {
  height: 100%;
  background: #00ff41;
  transition: width 0.15s;
}
.enemy.elite .label { color: #ffaa00; }
.enemy.elite .hp-fill { background: #ffaa00; }

/* Attack effect */
.attack-effect {
  position: absolute;
  color: #00ff41;
  font-size: 18px;
  font-weight: bold;
  pointer-events: none;
  animation: attackPop 0.4s ease-out forwards;
  z-index: 50;
}
@keyframes attackPop {
  0% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(2); }
}

/* Sub attack effect */
.sub-attack-effect {
  position: absolute;
  color: #ff66aa;
  font-size: 14px;
  font-weight: bold;
  pointer-events: none;
  animation: attackPop 0.4s ease-out forwards;
  z-index: 50;
}

/* Chain line effect */
.chain-effect {
  position: absolute;
  height: 2px;
  background: #ff66aa;
  pointer-events: none;
  transform-origin: left center;
  animation: chainFade 0.3s ease-out forwards;
  z-index: 49;
}
@keyframes chainFade {
  0% { opacity: 1; }
  100% { opacity: 0; }
}

/* Orbit effect */
.orbit-marker {
  position: absolute;
  width: 8px;
  height: 8px;
  background: #ff66aa;
  border-radius: 50%;
  pointer-events: none;
  z-index: 49;
  box-shadow: 0 0 6px #ff66aa;
}

/* Damage numbers */
.damage-number {
  position: absolute;
  font-size: 16px;
  font-weight: bold;
  color: #ff4444;
  pointer-events: none;
  animation: floatUp 0.8s ease-out forwards;
  z-index: 50;
}
.damage-number.crit { font-size: 22px; color: #ffaa00; }
.damage-number.sub-dmg { color: #ff66aa; font-size: 14px; }
@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-40px); }
}

/* Drops */
.drop {
  position: absolute;
  font-size: 12px;
  padding: 2px 6px;
  border: 1px solid;
  cursor: pointer;
  animation: dropBounce 0.3s ease-out;
  z-index: 30;
}
.drop.common { color: #aaa; border-color: #aaa; }
.drop.uncommon { color: #00ff41; border-color: #00ff41; }
.drop.rare { color: #4488ff; border-color: #4488ff; }
.drop.epic { color: #aa44ff; border-color: #aa44ff; }
.drop.legendary { color: #ffaa00; border-color: #ffaa00; text-shadow: 0 0 8px #ffaa00; }
.drop.unique { color: #ff2222; border-color: #ff2222; text-shadow: 0 0 8px #ff2222; }
@keyframes dropBounce {
  0% { transform: translateY(-20px); opacity: 0; }
  100% { transform: translateY(0); opacity: 1; }
}

/* Upgrade panel (right side) */
#upgrade-panel {
  position: fixed;
  top: 50px;
  right: 10px;
  width: 220px;
  background: rgba(0,0,0,0.85);
  border: 1px solid #00ff41;
  padding: 8px;
  z-index: 100;
  font-size: 12px;
}
#upgrade-panel h3 {
  color: #ffaa00;
  font-size: 13px;
  margin-bottom: 6px;
  text-align: center;
}
.upgrade-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 3px 0;
  padding: 3px 4px;
}
.upgrade-btn {
  background: none;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  padding: 2px 8px;
  cursor: pointer;
  white-space: nowrap;
}
.upgrade-btn:hover { background: rgba(0,255,65,0.2); }
.upgrade-btn:disabled { color: #555; border-color: #555; cursor: default; }
.upgrade-btn:disabled:hover { background: none; }

/* Crosshair + splash range indicator */
#crosshair {
  position: fixed;
  pointer-events: none;
  z-index: 90;
  transform: translate(-50%, -50%);
  border: 1px solid rgba(0,255,65,0.4);
  border-radius: 50%;
}
#crosshair::after {
  content: '+';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #00ff41;
  font-size: 16px;
  font-weight: bold;
}
/* Shape variants */
#crosshair.shape-line {
  border-radius: 2px;
}
#crosshair.shape-cone {
  border-radius: 0;
  clip-path: polygon(50% 100%, 0% 0%, 100% 0%);
  border: none;
  background: rgba(0,255,65,0.1);
  border: 1px solid rgba(0,255,65,0.4);
}
#crosshair.shape-nova {
  border-radius: 50%;
  border-style: dashed;
}
#crosshair.shape-pierce-burst {
  border-radius: 2px;
  border-style: double;
}
#crosshair.shape-lock-on {
  border-radius: 50%;
  border-color: rgba(255,68,68,0.5);
}
#crosshair.shape-lock-on::after {
  content: '+3';
  color: #ff4444;
}

/* Status banner */
#status-banner {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 32px;
  color: #00ff41;
  z-index: 150;
  display: none;
  text-shadow: 0 0 20px #00ff41;
}
</style>
</head>
<body>

<div id="hud">
  <div>HACK.SIM</div>
  <div class="maplv-control">
    MapLv:<select id="maplv-select"></select>
  </div>
  <div>CREDITS: <span id="hud-credits">0</span></div>
  <div>SCORE: <span id="hud-score">0</span></div>
  <div><button id="save-btn" style="background:none;border:1px solid #00ff41;color:#00ff41;font-family:'Courier New',monospace;font-size:11px;cursor:pointer;padding:2px 6px;" onclick="event.stopPropagation();saveGame();this.textContent='SAVED';setTimeout(()=>this.textContent='SAVE',1000);">SAVE</button> <button id="reset-btn" style="background:none;border:1px solid #ff4444;color:#ff4444;font-family:'Courier New',monospace;font-size:11px;cursor:pointer;padding:2px 6px;" onclick="event.stopPropagation();if(confirm('Reset all progress?'))resetGame();">RESET</button></div>
</div>

<div id="bottom-hud">
  <div>CORES: <span id="hud-cores">1</span>/4</div>
  <div>ATK: <span id="hud-atk">10</span> | SPLASH: <span id="hud-splash">50</span> | CD: <span id="hud-cd">0.50</span>s</div>
  <div>CRIT: <span id="hud-crit">5</span>% x<span id="hud-critdmg">2.0</span></div>
  <div>KILLS: <span id="hud-kills">0</span></div>
  <div id="hud-synergy"></div>
</div>

<div id="inventory-panel">
  <h3>EQUIPMENT</h3>
  <div class="equip-section">
    <div class="section-title">── CORE ──</div>
    <div id="core-slots"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">── SUB ──</div>
    <div id="sub-slots"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">── MODULE ──</div>
    <div id="module-slots"></div>
  </div>
  <hr class="inv-separator">
  <div class="equip-section">
    <div class="section-title">── CORE [<span id="inv-count-core">0</span>/50] ──</div>
    <div id="inv-list-core"></div>
    <div class="inv-page-controls" id="inv-page-core"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">── SUB [<span id="inv-count-sub">0</span>/50] ──</div>
    <div id="inv-list-sub"></div>
    <div class="inv-page-controls" id="inv-page-sub"></div>
  </div>
  <div class="equip-section">
    <div class="section-title">── MODULE [<span id="inv-count-mod">0</span>/50] ──</div>
    <div id="inv-list-mod"></div>
    <div class="inv-page-controls" id="inv-page-mod"></div>
  </div>
  <hr class="inv-separator">
  <div class="equip-section">
    <div class="section-title" style="color:#ffaa00;">── FORGE ──</div>
    <div style="font-size:10px;color:#888;margin-bottom:4px;">3 same-type + same-archetype = 1 higher rarity</div>
    <div id="forge-options"></div>
  </div>
</div>

<div id="game-canvas"></div>
<div id="crosshair"></div>

<div id="status-banner"></div>

<div id="upgrade-panel">
  <h3>UPGRADES [¢<span id="hud-credits-panel">0</span>]</h3>
  <div id="upgrade-list"></div>
</div>

<div id="autosell-panel" style="position:fixed;bottom:60px;right:10px;width:220px;background:rgba(0,0,0,0.85);border:1px solid #00ff41;padding:8px;z-index:100;font-size:12px;">
  <h3 style="color:#ffaa00;font-size:13px;margin-bottom:6px;text-align:center;">AUTO SELL FILTER</h3>
  <div class="upgrade-row">
    <span>Min iLv:</span>
    <input id="autosell-ilv" type="number" min="0" value="0" style="width:50px;background:#0a0a0a;border:1px solid #00ff41;color:#00ff41;font-family:'Courier New',monospace;font-size:11px;padding:2px;">
  </div>
  <div class="upgrade-row">
    <span>Min Rarity:</span>
    <select id="autosell-rarity" style="background:#0a0a0a;border:1px solid #00ff41;color:#00ff41;font-family:'Courier New',monospace;font-size:11px;padding:2px;">
      <option value="common">common</option>
      <option value="uncommon">uncommon</option>
      <option value="rare">rare</option>
      <option value="epic">epic</option>
      <option value="legendary">legendary</option>
      <option value="unique">unique</option>
    </select>
  </div>
  <div class="upgrade-row">
    <button id="bulk-sell-btn" style="width:100%;background:none;border:1px solid #ff4444;color:#ff4444;font-family:'Courier New',monospace;font-size:11px;cursor:pointer;padding:3px;" onclick="event.stopPropagation();bulkSell();">SELL FILTERED</button>
  </div>
</div>

<div id="dps-panel" style="position:fixed;bottom:60px;left:10px;width:150px;background:rgba(0,0,0,0.85);border:1px solid #00ff41;padding:6px;z-index:100;font-size:11px;">
  <div style="color:#ffaa00;text-align:center;margin-bottom:4px;">DPS METER</div>
  <div>DPS: <span id="dps-value" style="color:#ff4444;">0</span></div>
  <div>Kills/s: <span id="kps-value" style="color:#00ffff;">0</span></div>
  <div>Cr/s: <span id="cps-value" style="color:#ffaa00;">0</span></div>
</div>

<div class="item-tooltip" id="item-tooltip"></div>

<script>
// ---- CONFIG ----
const CANVAS_PAD_TOP = 40;
const CANVAS_PAD_BOT = 40;
const SPAWN_INTERVAL = 0.3;
const ENEMY_TYPES = [
  { tag: 'SRV', baseHp: 20, speed: 30, credits: 2, score: 10 },
  { tag: 'NODE', baseHp: 15, speed: 45, credits: 2, score: 10 },
  { tag: 'FW', baseHp: 50, speed: 20, credits: 5, score: 30 },
  { tag: 'DB', baseHp: 80, speed: 15, credits: 8, score: 50 },
  { tag: 'PROXY', baseHp: 30, speed: 55, credits: 3, score: 20 },
];
const ELITE_TYPE = { tag: 'MAINFRAME', baseHp: 300, speed: 10, credits: 30, score: 200, elite: true };

// Elite mutations - random modifiers applied to elites
const ELITE_MUTATIONS = [
  { tag: 'SWIFT', color: '#00ffff', hpMult: 0.7, speedMult: 2.5, creditsMult: 1.5 },
  { tag: 'ARMORED', color: '#888888', hpMult: 3.0, speedMult: 0.5, creditsMult: 2.0 },
  { tag: 'SPLITTING', color: '#88ff00', hpMult: 0.8, speedMult: 1.2, creditsMult: 1.8, splits: true },
  { tag: 'SHIELDED', color: '#4488ff', hpMult: 1.5, speedMult: 1.0, creditsMult: 2.0, shield: true },
  { tag: 'BERSERKER', color: '#ff4444', hpMult: 1.2, speedMult: 1.0, creditsMult: 1.5, berserker: true },
];

// Boss definitions - appear at MapLv 10, 20, 30, etc.
const BOSS_TYPES = [
  { tag: 'KERNEL_ZERO', baseHp: 2000, speed: 8, credits: 200, score: 1000 },
  { tag: 'ROOT_DAEMON', baseHp: 3000, speed: 6, credits: 300, score: 1500 },
  { tag: 'VOID_PROXY', baseHp: 5000, speed: 12, credits: 500, score: 2500 },
  { tag: 'OVERFLOW_GOD', baseHp: 8000, speed: 5, credits: 800, score: 4000 },
  { tag: 'SINGULARITY', baseHp: 15000, speed: 4, credits: 1500, score: 8000 },
];
const RARITIES = ['common','uncommon','rare','epic','legendary','unique'];
const RARITY_WEIGHTS = [50, 30, 14, 5, 1, 0.1];
const RARITY_AFFIX_COUNT = { common: 0, uncommon: 1, rare: 2, epic: 3, legendary: 4, unique: 5 };
const ATTACK_SHAPES = ['circle', 'line', 'cone', 'nova', 'pierce-burst', 'lock-on'];
const AUTO_MODES = ['nearest', 'chain', 'explode', 'orbit', 'parasite', 'drone'];

// ---- ARCHETYPES ----
const ARCHETYPES = {
  speed: { label: 'SPEED', color: '#00ffff', desc: 'CD -5% per item' },
  area:  { label: 'AREA',  color: '#ff8800', desc: 'Splash +10% per item' },
  dot:   { label: 'DOT',   color: '#88ff00', desc: 'SUB ATK +8% per item' },
};
const CORE_SHAPE_ARCHETYPE = { line: 'speed', 'pierce-burst': 'speed', 'lock-on': 'speed', cone: 'area', nova: 'area', circle: 'area' };
const SUB_MODE_ARCHETYPE = { nearest: 'speed', drone: 'speed', chain: 'dot', explode: 'dot', parasite: 'dot', orbit: 'area' };

// Named unique items (templates)
const NAMED_UNIQUES = [
  {
    name: 'Quicksilver Protocol', type: 'core', archetype: 'speed',
    attackShape: 'pierce-burst',
    baseAtk: 30, baseSplash: 30, baseCd: 0.15,
    fixedAffixes: [
      { id: 'pctCd', value: 15, label: (v) => `CD -${v}%` },
      { id: 'critChance', value: 8, label: (v) => `CritChance +${v}%` },
      { id: 'critDmg', value: 20, label: (v) => `CritDMG +${v}%` },
      { id: 'flatAtk', value: 15, label: (v) => `ATK +${v}` },
      { id: 'pctAtk', value: 10, label: (v) => `ATK +${v}%` },
    ],
  },
  {
    name: 'Cascade Engine', type: 'core', archetype: 'area',
    attackShape: 'nova',
    baseAtk: 18, baseSplash: 200, baseCd: 0.8,
    fixedAffixes: [
      { id: 'flatSplash', value: 30, label: (v) => `Splash +${v}` },
      { id: 'pctAtk', value: 15, label: (v) => `ATK +${v}%` },
      { id: 'dropRate', value: 5, label: (v) => `DropRate +${v}%` },
      { id: 'flatAtk', value: 10, label: (v) => `ATK +${v}` },
      { id: 'critDmg', value: 12, label: (v) => `CritDMG +${v}%` },
    ],
  },
  {
    name: 'Plague Vector', type: 'sub', archetype: 'dot',
    autoMode: 'parasite',
    baseAtk: 25,
    fixedAffixes: [
      { id: 'pctAtk', value: 20, label: (v) => `ATK +${v}%` },
      { id: 'xpBonus', value: 10, label: (v) => `Credits +${v}%` },
      { id: 'critDmg', value: 15, label: (v) => `CritDMG +${v}%` },
      { id: 'critChance', value: 5, label: (v) => `CritChance +${v}%` },
      { id: 'flatAtk', value: 12, label: (v) => `ATK +${v}` },
    ],
  },
];
const CORE_NAMES = [
  'Ping Flood','Port Scanner','SQL Injector','Buffer Overflow',
  'Zero-Day Exploit','Rootkit Launcher','Worm Deployer','Trojan Horse',
  'DDoS Cannon','Crypto Breaker','Firewall Piercer','Kernel Panic'
];
const SUB_NAMES = [
  'Packet Sniffer','Backdoor Agent','Keylogger Mk2','Spyware Beacon',
  'Brute Forcer','Phishing Relay','Adware Spreader','Botnet Node',
  'Proxy Chain','DNS Poisoner','Session Hijacker','Payload Dropper'
];
const MODULE_NAMES = [
  'Logic Amplifier','Cache Optimizer','Thread Scheduler','Memory Allocator',
  'Pipeline Booster','Signal Enhancer','Packet Compressor','Clock Multiplier',
  'Branch Predictor','Entropy Filter','Hash Accelerator','Codec Overdriver'
];

const AFFIX_POOL = [
  { id: 'flatAtk',    label: (v) => `ATK +${v}`,           gen: (ilv) => randInt(2 + ilv, 5 + ilv * 2) },
  { id: 'pctAtk',     label: (v) => `ATK +${v}%`,          gen: (ilv) => randInt(3, 8 + ilv) },
  { id: 'flatSplash', label: (v) => `Splash +${v}`,        gen: (ilv) => randInt(5, 15 + ilv * 2) },
  { id: 'pctCd',      label: (v) => `CD -${v}%`,           gen: (ilv) => randInt(2, 6 + Math.floor(ilv / 2)) },
  { id: 'critChance', label: (v) => `CritChance +${v}%`,   gen: (ilv) => randInt(1, 4 + Math.floor(ilv / 3)) },
  { id: 'critDmg',    label: (v) => `CritDMG +${v}%`,      gen: (ilv) => randInt(5, 15 + ilv) },
  { id: 'xpBonus',    label: (v) => `Credits +${v}%`,       gen: (ilv) => randInt(3, 8 + ilv) },
  { id: 'dropRate',   label: (v) => `DropRate +${v}%`,     gen: (ilv) => randInt(2, 5 + Math.floor(ilv / 2)) },
];

const INV_PAGE_SIZE = 5;
const MAX_INVENTORY = 50;

// ---- STATE ----
let state = {
  running: false,
  paused: false,
  mapLv: 1,
  spawnTimer: 0,
  score: 0,
  kills: 0,
  credits: 0,
  enemies: [],
  drops: [],
  equipped: {
    cores: [null, null, null, null],
    subs: [null, null, null, null],
    modules: [null, null, null, null],
  },
  cooldown: 0,
  mouseX: 0,
  mouseY: 0,
  upgrades: { atkMult: 1, rangeMult: 1, cdMult: 1, splashMult: 1, critChance: 0.05, critMult: 2, creditMult: 1, dropMult: 1, allDmgMult: 1, subAtkMult: 1 },
  autoSellFilter: { minIlv: 0, minRarity: 'common' },
  skillLevels: {},
  inventories: { cores: [], subs: [], modules: [] },
  invPages: { cores: 0, subs: 0, modules: 0 },
  subCooldowns: [0, 0, 0, 0],
  orbitAngles: [0, 0, 0, 0],
  // Track explode kills per sub
  pendingExplosions: [],
  infections: [],
  drones: [],
  bossActive: false,
  bossSpawned: {}, // mapLv -> true
  // DPS tracking
  dpsLog: [], // [{time, dmg}]
  killLog: [], // [{time}]
  creditLog: [], // [{time, amount}]
  milestoneNext: 1000,
};

const canvas = document.getElementById('game-canvas');

// ---- MAP LEVEL HELPERS ----
function getEnemyHpMult() { return Math.pow(1.08, state.mapLv - 1); }
function getMaxEnemies() { return Math.min(80, 12 + state.mapLv * 4); }
function getEliteRate() { return Math.min(0.5, 0.03 + state.mapLv * 0.01); }
function getScoreXpMult() { return Math.pow(1.06, state.mapLv - 1); }

// ---- AUDIO ----
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
// Pentatonic scale for musical hits
const PENTA = [261.6, 293.7, 329.6, 392.0, 440.0, 523.3, 587.3, 659.3];
let noteIdx = 0;

function playNote(freq, type, vol, dur) {
  const t = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = type;
  osc.frequency.value = freq;
  gain.gain.value = vol;
  gain.gain.exponentialRampToValueAtTime(0.001, t + dur);
  osc.start(t);
  osc.stop(t + dur);
}

// CORE attack sounds — different per shape
function playHitSound(crit, shape) {
  const base = PENTA[noteIdx % PENTA.length];
  noteIdx++;
  const freq = crit ? base * 2 : base;
  const vol = crit ? 0.1 : 0.06;
  switch (shape) {
    case 'line':
      playNote(freq, 'sawtooth', vol, 0.06);
      setTimeout(() => playNote(freq * 1.5, 'sawtooth', vol * 0.5, 0.04), 30);
      break;
    case 'cone':
      playNote(freq * 0.8, 'triangle', vol, 0.1);
      break;
    case 'nova':
      playNote(freq * 0.5, 'sine', vol, 0.15);
      setTimeout(() => playNote(freq, 'sine', vol * 0.6, 0.1), 50);
      break;
    default: // circle
      playNote(freq, 'square', vol, 0.07);
      break;
  }
}

// SUB auto-attack sounds
function playSubSound(mode) {
  switch (mode) {
    case 'nearest':
      playNote(523, 'sine', 0.04, 0.05);
      break;
    case 'chain':
      playNote(440, 'triangle', 0.03, 0.04);
      setTimeout(() => playNote(554, 'triangle', 0.025, 0.04), 40);
      setTimeout(() => playNote(659, 'triangle', 0.02, 0.04), 80);
      break;
    case 'explode':
      playNote(110, 'sawtooth', 0.06, 0.2);
      setTimeout(() => playNote(80, 'square', 0.04, 0.15), 50);
      break;
    case 'orbit':
      playNote(392 + Math.random() * 100, 'sine', 0.02, 0.03);
      break;
    case 'parasite':
      playNote(110, 'sawtooth', 0.05, 0.15);
      playNote(117, 'square', 0.04, 0.12);
      break;
    case 'drone':
      playNote(800 + Math.random() * 200, 'sawtooth', 0.02, 0.03);
      setTimeout(() => playNote(600 + Math.random() * 200, 'sawtooth', 0.015, 0.02), 15);
      break;
  }
}

function playPierceBurstSound() {
  playNote(600, 'square', 0.05, 0.04);
  setTimeout(() => playNote(750, 'square', 0.05, 0.04), 50);
  setTimeout(() => playNote(900, 'square', 0.05, 0.04), 100);
}

function playLockOnMarkSound() {
  playNote(880, 'sine', 0.04, 0.06);
}

function playLockOnDetonateSound() {
  playNote(80, 'sawtooth', 0.08, 0.3);
  setTimeout(() => playNote(60, 'square', 0.06, 0.25), 40);
}

// Kill sounds — vary by enemy type
function playKillSound(tag) {
  const t = audioCtx.currentTime;
  switch (tag) {
    case 'MAINFRAME':
      playNote(150, 'sawtooth', 0.08, 0.3);
      setTimeout(() => playNote(100, 'square', 0.06, 0.2), 80);
      setTimeout(() => playNote(60, 'sawtooth', 0.05, 0.25), 160);
      break;
    case 'FW':
    case 'DB':
      playNote(180, 'sawtooth', 0.06, 0.2);
      setTimeout(() => playNote(90, 'sawtooth', 0.04, 0.15), 60);
      break;
    default:
      playNote(200 + Math.random() * 100, 'sawtooth', 0.05, 0.12);
      break;
  }
}

// Drop pickup
function playDropSound(rarity) {
  const rarityFreqs = { common: 440, uncommon: 523, rare: 587, epic: 659, legendary: 784, unique: 880 };
  const freq = rarityFreqs[rarity] || 440;
  playNote(freq, 'sine', 0.06, 0.08);
  setTimeout(() => playNote(freq * 1.5, 'sine', 0.04, 0.1), 60);
}

// Equip sound
function playEquipSound() {
  playNote(523, 'square', 0.05, 0.05);
  setTimeout(() => playNote(659, 'square', 0.05, 0.05), 50);
  setTimeout(() => playNote(784, 'square', 0.05, 0.08), 100);
}

// ---- UTILITIES ----
function rand(min, max) { return Math.random() * (max - min) + min; }
function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
function pickWeighted(items, weights) {
  const total = weights.reduce((a, b) => a + b, 0);
  let r = Math.random() * total;
  for (let i = 0; i < items.length; i++) { r -= weights[i]; if (r <= 0) return items[i]; }
  return items[items.length - 1];
}
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

// ---- COMPUTED STATS ----
function getComputedStats() {
  let baseAtk = 0, baseSplash = 0, baseCd = Infinity;
  let coreCount = 0;
  for (const c of state.equipped.cores) {
    if (c) {
      baseAtk += c.atk;
      baseSplash = Math.max(baseSplash, c.splash);
      baseCd = Math.min(baseCd, c.cd);
      coreCount++;
    }
  }
  for (const s of state.equipped.subs) {
    if (s) {
      baseAtk += s.atk;
    }
  }

  if (coreCount === 0) return { atk: 0, splash: 30, cd: 1, critChance: 0, critDmg: 0, xpBonus: 0, dropBonus: 0, coreCount: 0 };

  let affixTotals = { flatAtk: 0, pctAtk: 0, flatSplash: 0, pctCd: 0, critChance: 0, critDmg: 0, xpBonus: 0, dropRate: 0 };
  const allEquipped = [...state.equipped.cores, ...state.equipped.subs, ...state.equipped.modules];
  for (const item of allEquipped) {
    if (!item || !item.affixes) continue;
    for (const af of item.affixes) {
      affixTotals[af.id] = (affixTotals[af.id] || 0) + af.value;
    }
  }

  let atk = (baseAtk + affixTotals.flatAtk) * (1 + affixTotals.pctAtk / 100);
  let splash = baseSplash + affixTotals.flatSplash;
  let cd = baseCd * (1 - affixTotals.pctCd / 100);
  cd = Math.max(0.15, cd);

  atk = atk * state.upgrades.atkMult;
  splash = splash * state.upgrades.splashMult;
  cd = cd * state.upgrades.cdMult;

  let critChance = (state.upgrades.critChance + affixTotals.critChance / 100);
  let critDmg = (state.upgrades.critMult + affixTotals.critDmg / 100);
  let xpBonus = affixTotals.xpBonus / 100;
  let dropBonus = affixTotals.dropRate / 100;

  // ---- STAT CAPS (hard limits) ----
  atk = Math.floor(atk);                          // no cap on ATK (scales with MapLv)
  splash = Math.min(200, Math.floor(splash));      // max 200px radius
  cd = Math.max(0.15, Math.round(cd * 100) / 100); // min 0.15s
  critChance = Math.min(0.75, critChance);          // max 75%
  critDmg = Math.min(10, critDmg);                  // max 10x
  xpBonus = Math.min(5, xpBonus);                   // max +500% credits
  dropBonus = Math.min(3, dropBonus);                // max +300% drop rate

  // ---- SYNERGY BONUSES ----
  const synergyCounts = { speed: 0, area: 0, dot: 0 };
  for (const item of allEquipped) {
    if (item && item.archetype && synergyCounts[item.archetype] !== undefined) {
      synergyCounts[item.archetype]++;
    }
  }
  // SPEED: CD -5% per item, max -30%
  const speedBonus = Math.min(6, synergyCounts.speed) * 0.05;
  cd = cd * (1 - speedBonus);
  cd = Math.max(0.15, Math.round(cd * 100) / 100);
  // AREA: Splash +10% per item, max +60%
  const areaBonus = Math.min(6, synergyCounts.area) * 0.10;
  splash = Math.min(200, Math.floor(splash * (1 + areaBonus)));
  // DOT: SUB ATK +8% per item, max +48% (stored as multiplier for sub damage)
  const dotBonus = Math.min(6, synergyCounts.dot) * 0.08;

  return { atk, splash, cd, critChance, critDmg, xpBonus, dropBonus, coreCount, synergyCounts, dotBonus };
}

// ---- ITEM GENERATION ----
function generateAffixes(ilv, count) {
  if (count === 0) return [];
  const affixes = [];
  const usedIds = new Set();
  for (let i = 0; i < count; i++) {
    const available = AFFIX_POOL.filter(a => !usedIds.has(a.id));
    if (available.length === 0) break;
    const pick = available[randInt(0, available.length - 1)];
    usedIds.add(pick.id);
    affixes.push({ id: pick.id, value: pick.gen(ilv), label: pick.label });
  }
  return affixes;
}

function makeItem(rarity, mapLv) {
  const roll = Math.random();
  const itemType = roll < 0.4 ? 'core' : roll < 0.7 ? 'sub' : 'module';
  const ilv = mapLv;
  const rarityIdx = RARITIES.indexOf(rarity);
  const affixCount = RARITY_AFFIX_COUNT[rarity];
  const affixes = generateAffixes(ilv, affixCount);
  const ilvScale = 1 + (ilv - 1) * 0.15;
  const isUnique = rarity === 'unique';
  const uniqueMult = isUnique ? 1.5 : 1;

  if (itemType === 'core') {
    const baseName = CORE_NAMES[randInt(0, CORE_NAMES.length - 1)];
    const attackShape = ATTACK_SHAPES[randInt(0, ATTACK_SHAPES.length - 1)];
    const archetype = CORE_SHAPE_ARCHETYPE[attackShape] || 'area';
    return {
      id: Date.now() + Math.random(),
      type: 'core',
      name: baseName,
      rarity, ilv,
      atk: Math.floor((8 + rarityIdx * 6 + randInt(0, 4)) * ilvScale * uniqueMult),
      splash: Math.floor((45 + rarityIdx * 15 + randInt(0, 10)) * (1 + (ilv - 1) * 0.05) * uniqueMult),
      cd: Math.round(Math.max(0.1, (0.6 - rarityIdx * 0.08 + rand(-0.05, 0.05)) / uniqueMult) * 100) / 100,
      affixes,
      attackShape,
      archetype,
    };
  } else if (itemType === 'sub') {
    const baseName = SUB_NAMES[randInt(0, SUB_NAMES.length - 1)];
    const autoMode = AUTO_MODES[randInt(0, AUTO_MODES.length - 1)];
    const archetype = SUB_MODE_ARCHETYPE[autoMode] || 'speed';
    return {
      id: Date.now() + Math.random(),
      type: 'sub',
      name: baseName,
      rarity, ilv,
      atk: Math.floor((4 + rarityIdx * 4 + randInt(0, 3)) * ilvScale * uniqueMult),
      affixes,
      autoMode,
      archetype,
    };
  } else {
    const baseName = MODULE_NAMES[randInt(0, MODULE_NAMES.length - 1)];
    const archetypeKeys = Object.keys(ARCHETYPES);
    const archetype = archetypeKeys[randInt(0, archetypeKeys.length - 1)];
    return {
      id: Date.now() + Math.random(),
      type: 'module',
      name: baseName,
      rarity, ilv,
      affixes,
      archetype,
    };
  }
}

// ---- ENEMY MANAGEMENT ----
function spawnBoss() {
  if (state.bossActive) return;
  const bossIdx = Math.min(Math.floor((state.mapLv - 1) / 10), BOSS_TYPES.length - 1);
  const tmpl = BOSS_TYPES[bossIdx];
  const scaledHp = Math.floor(tmpl.baseHp * getEnemyHpMult());
  const w = window.innerWidth, h = window.innerHeight;
  const enemy = {
    id: Date.now() + Math.random(),
    tag: tmpl.tag,
    hp: scaledHp, maxHp: scaledHp,
    speed: tmpl.speed,
    credits: tmpl.credits,
    score: tmpl.score,
    elite: true, boss: true,
    x: w / 2, y: CANVAS_PAD_TOP + 80,
    el: null, vx: 0, vy: 0, marked: false,
  };
  const el = document.createElement('div');
  el.className = 'enemy elite';
  el.innerHTML = `<div class="hitbox"></div><div class="label" style="color:#ff4444;font-size:18px;text-shadow:0 0 10px #ff4444;">[BOSS:${enemy.tag}:${enemy.hp}]</div><div class="hp-bar"><div class="hp-fill" style="background:#ff4444;"></div></div>`;
  el.style.left = enemy.x + 'px';
  el.style.top = enemy.y + 'px';
  canvas.appendChild(el);
  enemy.el = el;
  enemy.labelEl = el.querySelector('.label');
  enemy.hpFillEl = el.querySelector('.hp-fill');
  enemy.hitboxEl = el.querySelector('.hitbox');
  state.enemies.push(enemy);
  state.bossActive = true;
  showBanner('BOSS: ' + enemy.tag);
}

function spawnEnemy() {
  if (!state.running) return;

  // Boss spawn at MapLv multiples of 10
  if (state.mapLv >= 10 && state.mapLv % 10 === 0 && !state.bossSpawned[state.mapLv] && !state.bossActive) {
    state.bossSpawned[state.mapLv] = true;
    spawnBoss();
  }

  const isElite = Math.random() < getEliteRate();
  const template = isElite ? ELITE_TYPE : ENEMY_TYPES[randInt(0, ENEMY_TYPES.length - 1)];
  const scaledHp = Math.floor(template.baseHp * getEnemyHpMult());
  const w = window.innerWidth;
  const h = window.innerHeight;
  const side = randInt(0, 3);
  let x, y;
  const margin = 60;
  if (side === 0) { x = rand(margin, w - margin); y = CANVAS_PAD_TOP + margin; }
  else if (side === 1) { x = rand(margin, w - margin); y = h - CANVAS_PAD_BOT - margin; }
  else if (side === 2) { x = margin; y = rand(CANVAS_PAD_TOP + margin, h - CANVAS_PAD_BOT - margin); }
  else { x = w - margin; y = rand(CANVAS_PAD_TOP + margin, h - CANVAS_PAD_BOT - margin); }

  const enemy = {
    id: Date.now() + Math.random(),
    tag: template.tag,
    hp: scaledHp,
    maxHp: scaledHp,
    speed: template.speed + rand(-5, 5),
    credits: template.credits,
    score: template.score,
    elite: !!template.elite,
    x, y,
    el: null,
    vx: 0, vy: 0,
    marked: false,
    mutation: null,
    boss: false,
    shield: 0,
    splits: false,
    berserker: false,
  };

  // Apply mutation to elites
  if (enemy.elite && Math.random() < 0.6) {
    const mut = ELITE_MUTATIONS[randInt(0, ELITE_MUTATIONS.length - 1)];
    enemy.mutation = mut;
    enemy.hp = Math.floor(enemy.hp * mut.hpMult);
    enemy.maxHp = enemy.hp;
    enemy.speed *= mut.speedMult;
    enemy.credits = Math.floor(enemy.credits * mut.creditsMult);
    enemy.tag = mut.tag + '_' + enemy.tag;
    if (mut.shield) enemy.shield = Math.floor(enemy.maxHp * 0.3);
    if (mut.splits) enemy.splits = true;
    if (mut.berserker) enemy.berserker = true;
  }

  const angle = Math.random() * Math.PI * 2;
  enemy.vx = Math.cos(angle) * enemy.speed;
  enemy.vy = Math.sin(angle) * enemy.speed;

  const mutColor = enemy.mutation ? ` style="color:${enemy.mutation.color}"` : '';
  const shieldText = enemy.shield > 0 ? `[S:${enemy.shield}]` : '';
  const el = document.createElement('div');
  el.className = 'enemy' + (enemy.elite ? ' elite' : '');
  el.innerHTML = `<div class="hitbox"></div><div class="label"${mutColor}>${shieldText}[${enemy.tag}:${enemy.hp}]</div><div class="hp-bar"><div class="hp-fill"></div></div>`;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  canvas.appendChild(el);
  enemy.el = el;
  enemy.labelEl = el.querySelector('.label');
  enemy.hpFillEl = el.querySelector('.hp-fill');
  enemy.hitboxEl = el.querySelector('.hitbox');
  state.enemies.push(enemy);
}

// Apply damage respecting shield
function applyDamage(enemy, dmg) {
  if (enemy.shield > 0) {
    if (dmg <= enemy.shield) {
      enemy.shield -= dmg;
      return;
    }
    dmg -= enemy.shield;
    enemy.shield = 0;
  }
  applyDamage(enemy, dmg);
}

function removeEnemy(enemy) {
  if (enemy.el) enemy.el.remove();
  state.enemies = state.enemies.filter(e => e.id !== enemy.id);
}

function updateEnemies(dt) {
  const w = window.innerWidth;
  const h = window.innerHeight;
  for (const e of state.enemies) {
    const cx = w / 2, cy = h / 2;
    const pullDx = cx - e.x, pullDy = cy - e.y;
    const pullDist = Math.hypot(pullDx, pullDy) || 1;
    e.vx += (pullDx / pullDist) * 40 * dt;
    e.vy += (pullDy / pullDist) * 40 * dt;
    e.vx *= 0.97;
    e.vy *= 0.97;
    if (Math.random() < 0.02) {
      const angle = Math.random() * Math.PI * 2;
      e.vx += Math.cos(angle) * e.speed * 0.4;
      e.vy += Math.sin(angle) * e.speed * 0.4;
    }
    for (const other of state.enemies) {
      if (other.id === e.id) continue;
      const dx = e.x - other.x;
      const dy = e.y - other.y;
      const d = Math.hypot(dx, dy);
      if (d < 50 && d > 0) {
        e.vx += (dx / d) * (50 - d) * 0.2 * dt;
        e.vy += (dy / d) * (50 - d) * 0.2 * dt;
      }
    }
    const spd = Math.hypot(e.vx, e.vy);
    if (spd > e.speed * 1.5) {
      e.vx = (e.vx / spd) * e.speed * 1.5;
      e.vy = (e.vy / spd) * e.speed * 1.5;
    }
    e.x += e.vx * dt;
    e.y += e.vy * dt;
    let bounced = false;
    if (e.x < 10) { e.x = 10; bounced = true; }
    if (e.x > w - 10) { e.x = w - 10; bounced = true; }
    if (e.y < CANVAS_PAD_TOP + 10) { e.y = CANVAS_PAD_TOP + 10; bounced = true; }
    if (e.y > h - CANVAS_PAD_BOT - 10) { e.y = h - CANVAS_PAD_BOT - 10; bounced = true; }
    if (bounced) {
      const toCenterAngle = Math.atan2(cy - e.y, cx - e.x);
      const scatter = (Math.random() - 0.5) * Math.PI * 0.5;
      e.vx = Math.cos(toCenterAngle + scatter) * e.speed;
      e.vy = Math.sin(toCenterAngle + scatter) * e.speed;
    }
    e.el.style.left = e.x + 'px';
    e.el.style.top = e.y + 'px';
    // Berserker: speed increases as HP drops
    if (e.berserker && e.hp < e.maxHp * 0.5) {
      const rage = 1 + (1 - e.hp / e.maxHp) * 2;
      const spd = Math.hypot(e.vx, e.vy);
      if (spd > 0 && spd < e.speed * rage) {
        e.vx *= 1.02;
        e.vy *= 1.02;
      }
    }
    const shieldText = e.shield > 0 ? `[S:${e.shield}]` : '';
    const bossPrefix = e.boss ? 'BOSS:' : '';
    e.labelEl.textContent = e.marked ? `[!]${shieldText}[${bossPrefix}${e.tag}:${e.hp}]` : `${shieldText}[${bossPrefix}${e.tag}:${e.hp}]`;
    const hpPct = Math.max(0, e.hp / e.maxHp * 100);
    e.hpFillEl.style.width = hpPct + '%';
  }
}

// ---- ATTACK (with CORE shapes) ----
function getEnemyCenter(e) {
  if (e.hitboxEl) {
    const r = e.hitboxEl.getBoundingClientRect();
    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
  }
  return { x: e.x + 35, y: e.y + 10 };
}

function isInCircle(ex, ey, cx, cy, radius) {
  return dist(ex, ey, cx, cy) <= radius;
}

function isInLine(ex, ey, ox, oy, angle, width, length) {
  const dx = ex - ox, dy = ey - oy;
  const along = dx * Math.cos(angle) + dy * Math.sin(angle);
  const perp = Math.abs(-dx * Math.sin(angle) + dy * Math.cos(angle));
  return along >= 0 && along <= length && perp <= width / 2;
}

function isInCone(ex, ey, ox, oy, angle, halfAngle, radius) {
  const d = dist(ex, ey, ox, oy);
  if (d > radius) return false;
  const a = Math.atan2(ey - oy, ex - ox);
  let diff = a - angle;
  while (diff > Math.PI) diff -= Math.PI * 2;
  while (diff < -Math.PI) diff += Math.PI * 2;
  return Math.abs(diff) <= halfAngle;
}

function isInNova(ex, ey, cx, cy, innerR, outerR) {
  const d = dist(ex, ey, cx, cy);
  return d >= innerR && d <= outerR;
}

function attack(mx, my) {
  if (state.cooldown > 0 || state.paused) return;
  const stats = getComputedStats();
  if (stats.coreCount === 0) return;

  const playerX = window.innerWidth / 2;
  const playerY = window.innerHeight / 2;
  const clickAngle = Math.atan2(my - playerY, mx - playerX);

  // Each equipped CORE fires its own shape
  const toKill = new Set();
  const damaged = new Set();
  let lockOnTargets = null;

  for (const core of state.equipped.cores) {
    if (!core) continue;
    const shape = core.attackShape || 'circle';
    const splash = Math.floor(core.splash * state.upgrades.splashMult);

    // Show effect
    showAttackEffect(mx, my, shape, splash, clickAngle, playerX, playerY);

    for (const e of state.enemies) {
      if (damaged.has(e.id)) continue; // only hit once per click per enemy across all cores
      const ec = getEnemyCenter(e);
      let hit = false;

      switch (shape) {
        case 'circle':
          hit = isInCircle(ec.x, ec.y, mx, my, splash);
          break;
        case 'line':
          hit = isInLine(ec.x, ec.y, mx, my, clickAngle, 30, splash * 3);
          break;
        case 'cone':
          hit = isInCone(ec.x, ec.y, mx, my, clickAngle, Math.PI / 6, splash * 1.5);
          break;
        case 'nova':
          hit = isInNova(ec.x, ec.y, playerX, playerY, splash * 0.5, splash * 2);
          break;
        case 'pierce-burst':
          hit = isInLine(ec.x, ec.y, mx, my, clickAngle, 40, splash * 2.5);
          break;
        case 'lock-on':
          hit = isInCircle(ec.x, ec.y, mx, my, splash);
          break;
      }

      if (hit && shape === 'pierce-burst') {
        damaged.add(e.id);
        const allMult = state.upgrades.allDmgMult || 1;
        const mults = [1.0, 0.6, 0.35];
        for (let p = 0; p < 3; p++) {
          setTimeout(() => {
            if (!state.enemies.includes(e)) return;
            const isCrit = Math.random() < stats.critChance;
            const dmg = Math.floor((isCrit ? stats.atk * stats.critDmg : stats.atk) * allMult * mults[p]);
            applyDamage(e, dmg);
            showDamageNumber(e.x, e.y, dmg, isCrit, false, 'pierce-burst');
            if (e.hp <= 0) killEnemy(e, false);
          }, p * 50);
        }
      } else if (hit && shape === 'lock-on') {
        // collect for lock-on marking (max 3)
        if (!lockOnTargets) lockOnTargets = [];
        if (lockOnTargets.length < 3) {
          damaged.add(e.id);
          lockOnTargets.push({ enemy: e, core });
        }
      } else if (hit) {
        damaged.add(e.id);
        const isCrit = Math.random() < stats.critChance;
        const allMult = state.upgrades.allDmgMult || 1;
        const dmg = Math.floor((isCrit ? stats.atk * stats.critDmg : stats.atk) * allMult);
        applyDamage(e, dmg);
        showDamageNumber(e.x, e.y, dmg, isCrit, false, core.attackShape);
        if (e.hp <= 0) toKill.add(e);
      }
    }
  }

  // Handle lock-on marks
  if (lockOnTargets && lockOnTargets.length > 0) {
    playLockOnMarkSound();
    for (const lt of lockOnTargets) {
      const e = lt.enemy;
      if (!state.enemies.includes(e)) continue;
      e.marked = true;
      e.labelEl.textContent = `[!][${e.tag}:${e.hp}]`;
      e.labelEl.style.color = '#ff4444';
    }
    setTimeout(() => {
      playLockOnDetonateSound();
      const allMult = state.upgrades.allDmgMult || 1;
      for (const lt of lockOnTargets) {
        const e = lt.enemy;
        if (!state.enemies.includes(e)) continue;
        e.marked = false;
        e.labelEl.style.color = '';
        const isCrit = Math.random() < stats.critChance;
        const dmg = Math.floor((isCrit ? stats.atk * stats.critDmg : stats.atk) * 1.5 * allMult);
        applyDamage(e, dmg);
        showDamageNumber(e.x, e.y, dmg, isCrit, false, 'lock-on');
        showAttackEffect(e.x, e.y, 'circle', 40, 0, e.x, e.y);
        if (e.hp <= 0) killEnemy(e, false);
      }
    }, 800);
  }

  // Handle pierce-burst effect & sound
  if (state.equipped.cores.some(c => c && c.attackShape === 'pierce-burst')) {
    playPierceBurstSound();
  }

  for (const e of toKill) killEnemy(e, false);
  state.cooldown = stats.cd;
}

function killEnemy(enemy, fromSub) {
  // Remove infections on this enemy (propagation handled in updateInfections)
  state.infections = state.infections.filter(inf => inf.enemyId !== enemy.id);
  playKillSound(enemy.tag);

  // Boss death
  if (enemy.boss) {
    state.bossActive = false;
    showBanner('BOSS DEFEATED');
  }

  // Splitting mutation: spawn 2 smaller enemies
  if (enemy.splits && !enemy.splitChild) {
    for (let i = 0; i < 2; i++) {
      const child = {
        id: Date.now() + Math.random() + i,
        tag: enemy.tag.replace('SPLITTING_', ''),
        hp: Math.floor(enemy.maxHp * 0.3),
        maxHp: Math.floor(enemy.maxHp * 0.3),
        speed: enemy.speed * 1.5,
        credits: Math.floor(enemy.credits * 0.3),
        score: Math.floor(enemy.score * 0.3),
        elite: false, boss: false,
        x: enemy.x + rand(-30, 30), y: enemy.y + rand(-30, 30),
        el: null, vx: 0, vy: 0, marked: false,
        mutation: null, shield: 0, splits: false, berserker: false, splitChild: true,
      };
      const a = Math.random() * Math.PI * 2;
      child.vx = Math.cos(a) * child.speed;
      child.vy = Math.sin(a) * child.speed;
      const el = document.createElement('div');
      el.className = 'enemy';
      el.innerHTML = `<div class="hitbox"></div><div class="label">[${child.tag}:${child.hp}]</div><div class="hp-bar"><div class="hp-fill"></div></div>`;
      el.style.left = child.x + 'px';
      el.style.top = child.y + 'px';
      canvas.appendChild(el);
      child.el = el;
      child.labelEl = el.querySelector('.label');
      child.hpFillEl = el.querySelector('.hp-fill');
      child.hitboxEl = el.querySelector('.hitbox');
      state.enemies.push(child);
    }
  }
  const mult = getScoreXpMult();
  const computed = getComputedStats();
  const creditMult = state.upgrades.creditMult * (1 + computed.xpBonus);
  state.score += Math.floor(enemy.score * mult);
  state.kills++;
  const earnedCredits = Math.floor(enemy.credits * mult * creditMult);
  state.credits += earnedCredits;
  logKill();
  logCredits(earnedCredits);
  checkMilestone();
  showCreditNumber(enemy.x, enemy.y, earnedCredits);

  const baseDropChance = 0.15;
  const dropChance = baseDropChance * state.upgrades.dropMult * (1 + computed.dropBonus);
  if (Math.random() < dropChance || enemy.elite) {
    spawnDrop(enemy.x, enemy.y, enemy.elite);
  }

  // Boss: guaranteed named unique drop
  if (enemy.boss) {
    const tmpl = NAMED_UNIQUES[randInt(0, NAMED_UNIQUES.length - 1)];
    spawnNamedUniqueDrop(enemy.x, enemy.y, tmpl, state.mapLv);
  }
  // Named unique drop from elites (2% chance each)
  else if (enemy.elite) {
    for (const tmpl of NAMED_UNIQUES) {
      if (Math.random() < 0.02) {
        spawnNamedUniqueDrop(enemy.x, enemy.y, tmpl, state.mapLv);
        break;
      }
    }
  }

  // Check for explode subs
  if (!fromSub) {
    for (let i = 0; i < 4; i++) {
      const sub = state.equipped.subs[i];
      if (sub && sub.autoMode === 'explode') {
        // Queue explosion at enemy position
        state.pendingExplosions.push({ x: enemy.x, y: enemy.y, atk: sub.atk });
      }
    }
  }

  removeEnemy(enemy);
}

// ---- EFFECTS ----
function showAttackEffect(x, y, shape, splash, angle, px, py) {
  const el = document.createElement('div');
  el.className = 'attack-effect';
  switch (shape) {
    case 'circle': el.textContent = '*'; break;
    case 'line': el.textContent = '---'; break;
    case 'cone': el.textContent = '>>'; break;
    case 'nova': el.textContent = '(*)'; el.style.left = (px - 9) + 'px'; el.style.top = (py - 9) + 'px'; canvas.appendChild(el); setTimeout(() => el.remove(), 400); return;
    case 'pierce-burst':
      for (let p = 0; p < 3; p++) {
        setTimeout(() => {
          const pe = document.createElement('div');
          pe.className = 'attack-effect';
          pe.textContent = '>>>';
          pe.style.left = (x + Math.cos(angle) * p * 30 - 9) + 'px';
          pe.style.top = (y + Math.sin(angle) * p * 30 - 9) + 'px';
          canvas.appendChild(pe);
          setTimeout(() => pe.remove(), 400);
        }, p * 50);
      }
      return;
    case 'lock-on': el.textContent = '[!]'; el.style.color = '#ff4444'; break;
  }
  el.style.left = (x - 9) + 'px';
  el.style.top = (y - 9) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 400);
}

function showDamageNumber(x, y, dmg, crit, isSub, shape, subMode) {
  const el = document.createElement('div');
  el.className = 'damage-number' + (crit ? ' crit' : '') + (isSub ? ' sub-dmg' : '');
  el.textContent = (crit ? 'CRIT ' : '') + dmg;
  el.style.left = (x + rand(-15, 15)) + 'px';
  el.style.top = (y - 10) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 800);
  if (!isSub) playHitSound(crit, shape);
  else if (subMode) playSubSound(subMode);
  logDamage(dmg);
}

function showCreditNumber(x, y, amount) {
  const el = document.createElement('div');
  el.className = 'damage-number';
  el.style.color = '#ffaa00';
  el.style.fontSize = '12px';
  el.textContent = '+' + amount + 'Cr';
  el.style.left = (x + rand(10, 30)) + 'px';
  el.style.top = (y + 5) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 800);
}

function showSubEffect(x, y, symbol) {
  const el = document.createElement('div');
  el.className = 'sub-attack-effect';
  el.textContent = symbol;
  el.style.left = (x - 7) + 'px';
  el.style.top = (y - 7) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 400);
}

function showChainLine(x1, y1, x2, y2) {
  const el = document.createElement('div');
  el.className = 'chain-effect';
  const dx = x2 - x1, dy = y2 - y1;
  const len = Math.hypot(dx, dy);
  const angle = Math.atan2(dy, dx);
  el.style.left = x1 + 'px';
  el.style.top = y1 + 'px';
  el.style.width = len + 'px';
  el.style.transform = `rotate(${angle}rad)`;
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 300);
}

// ---- SUB AUTO-ATTACK ----
function getSubDmgMult() {
  const stats = getComputedStats();
  return (state.upgrades.subAtkMult || 1) * (state.upgrades.allDmgMult || 1) * (1 + (stats.dotBonus || 0));
}

function updateSubAttacks(dt) {
  if (state.paused || state.enemies.length === 0) return;
  const stats = getComputedStats();
  const subMult = getSubDmgMult();

  for (let i = 0; i < 4; i++) {
    state.subCooldowns[i] = Math.max(0, state.subCooldowns[i] - dt);
    const sub = state.equipped.subs[i];
    if (!sub) continue;

    // Drone is continuous (handled separately)
    if (sub.autoMode === 'drone') continue;

    // Orbit is continuous
    if (sub.autoMode === 'orbit') {
      state.orbitAngles[i] = (state.orbitAngles[i] || 0) + dt * 3;
      const ox = state.mouseX + Math.cos(state.orbitAngles[i]) * 150;
      const oy = state.mouseY + Math.sin(state.orbitAngles[i]) * 150;
      // Damage enemies near orbit point (every tick)
      const dps = sub.atk * 2 * subMult; // DPS
      for (const e of state.enemies) {
        const ec = getEnemyCenter(e);
        if (dist(ec.x, ec.y, ox, oy) < 40) {
          const dmg = Math.max(1, Math.floor(dps * dt));
          applyDamage(e, dmg);
          if (Math.random() < 0.1) showDamageNumber(e.x, e.y, dmg, false, true, null, 'orbit');
          if (e.hp <= 0) {
            killEnemy(e, true);
            break;
          }
        }
      }
      continue;
    }

    if (state.subCooldowns[i] > 0) continue;

    const mx = state.mouseX, my = state.mouseY;
    // Find nearest enemy to cursor
    let nearest = null, nearDist = Infinity;
    for (const e of state.enemies) {
      const ec = getEnemyCenter(e);
      const d = dist(ec.x, ec.y, mx, my);
      if (d < nearDist) { nearDist = d; nearest = e; }
    }
    if (!nearest) continue;

    state.subCooldowns[i] = 1.5;

    switch (sub.autoMode) {
      case 'nearest': {
        const ec = getEnemyCenter(nearest);
        const isCrit = Math.random() < stats.critChance;
        const subBase = sub.atk * subMult;
        const dmg = Math.floor(isCrit ? subBase * stats.critDmg : subBase);
        applyDamage(nearest, dmg);
        showDamageNumber(nearest.x, nearest.y, dmg, isCrit, true, null, sub.autoMode);
        showSubEffect(ec.x, ec.y, '>');
        if (nearest.hp <= 0) killEnemy(nearest, true);
        break;
      }
      case 'chain': {
        let target = nearest;
        let chainDmg = sub.atk * subMult;
        const hit = new Set();
        for (let c = 0; c < 3 && target; c++) {
          const ec = getEnemyCenter(target);
          hit.add(target.id);
          const isCrit = Math.random() < stats.critChance;
          const dmg = isCrit ? Math.floor(chainDmg * stats.critDmg) : Math.floor(chainDmg);
          applyDamage(target, dmg);
          showDamageNumber(target.x, target.y, dmg, isCrit, true, null, 'chain');
          showSubEffect(ec.x, ec.y, '>');

          const prevEc = ec;
          if (target.hp <= 0) { killEnemy(target, true); }

          // Find next chain target
          chainDmg *= 0.7;
          let nextTarget = null, nextDist = Infinity;
          for (const e of state.enemies) {
            if (hit.has(e.id)) continue;
            const eec = getEnemyCenter(e);
            const d = dist(eec.x, eec.y, prevEc.x, prevEc.y);
            if (d < 200 && d < nextDist) { nextDist = d; nextTarget = e; }
          }
          if (nextTarget) {
            const nec = getEnemyCenter(nextTarget);
            showChainLine(prevEc.x, prevEc.y, nec.x, nec.y);
          }
          target = nextTarget;
        }
        break;
      }
      case 'explode': {
        const ec = getEnemyCenter(nearest);
        const isCrit = Math.random() < stats.critChance;
        const subBase = sub.atk * subMult;
        const dmg = Math.floor(isCrit ? subBase * stats.critDmg : subBase);
        applyDamage(nearest, dmg);
        showDamageNumber(nearest.x, nearest.y, dmg, isCrit, true, null, sub.autoMode);
        showSubEffect(ec.x, ec.y, '#');
        if (nearest.hp <= 0) killEnemy(nearest, false); // false to allow explode
        break;
      }
      case 'parasite': {
        // Infect nearest enemy if not already at max infections for this sub
        const myInfections = state.infections.filter(inf => inf.subIdx === i);
        if (myInfections.length < 3) {
          const alreadyInfected = new Set(state.infections.map(inf => inf.enemyId));
          // prefer uninfected nearest
          let target = null, tDist = Infinity;
          for (const e of state.enemies) {
            if (alreadyInfected.has(e.id)) continue;
            const ec = getEnemyCenter(e);
            const d = dist(ec.x, ec.y, mx, my);
            if (d < tDist) { tDist = d; target = e; }
          }
          if (!target) { // fallback to nearest
            for (const e of state.enemies) {
              const ec = getEnemyCenter(e);
              const d = dist(ec.x, ec.y, mx, my);
              if (d < tDist) { tDist = d; target = e; }
            }
          }
          if (target) {
            const dmgPerSec = sub.atk * 0.3 * subMult;
            state.infections.push({ enemyId: target.id, subIdx: i, dmgPerSec, ttl: 5 });
            playSubSound('parasite');
            const ec = getEnemyCenter(target);
            showSubEffect(ec.x, ec.y, '[P]');
          }
        }
        break;
      }
    }
  }

  // Process pending explosions
  const explosions = state.pendingExplosions.splice(0);
  for (const exp of explosions) {
    const explosionDmg = Math.floor(exp.atk * 0.5 * subMult);
    for (const e of [...state.enemies]) {
      const ec = getEnemyCenter(e);
      if (dist(ec.x, ec.y, exp.x + 35, exp.y + 10) < 120) {
        e.hp -= explosionDmg;
        showDamageNumber(e.x, e.y, explosionDmg, false, true, null, 'explode');
        if (e.hp <= 0) killEnemy(e, true);
      }
    }
  }
}

// ---- NAMED UNIQUE GENERATION ----
function makeNamedUnique(tmpl, mapLv) {
  const ilv = mapLv;
  const ilvScale = 1 + (ilv - 1) * 0.15;
  const item = {
    id: Date.now() + Math.random(),
    type: tmpl.type,
    name: tmpl.name,
    rarity: 'unique',
    ilv,
    affixes: tmpl.fixedAffixes.map(a => ({ ...a })),
    archetype: tmpl.archetype,
    namedUnique: true,
  };
  if (tmpl.type === 'core') {
    item.atk = Math.floor(tmpl.baseAtk * ilvScale * 1.5);
    item.splash = Math.floor(tmpl.baseSplash * (1 + (ilv - 1) * 0.05) * 1.5);
    item.cd = tmpl.baseCd;
    item.attackShape = tmpl.attackShape;
  } else if (tmpl.type === 'sub') {
    item.atk = Math.floor(tmpl.baseAtk * ilvScale * 1.5);
    item.autoMode = tmpl.autoMode;
  }
  return item;
}

function spawnNamedUniqueDrop(x, y, tmpl, mapLv) {
  const item = makeNamedUnique(tmpl, mapLv);
  const invKey = getInvKeyForType(item.type);
  if (state.inventories[invKey].length >= MAX_INVENTORY) return;

  const drop = {
    id: item.id,
    x: x + rand(-20, 20),
    y: y + rand(-10, 10),
    item,
    ttl: 15, // longer TTL for named uniques
    el: null,
  };

  const el = document.createElement('div');
  el.className = 'drop unique';
  const typeTag = item.type === 'core' ? 'C' : item.type === 'sub' ? 'S' : 'M';
  el.textContent = `[${typeTag}:iL${item.ilv} ${item.name}]`;
  el.style.left = drop.x + 'px';
  el.style.top = drop.y + 'px';
  el.addEventListener('mouseenter', () => { pickupDrop(drop); });
  canvas.appendChild(el);
  drop.el = el;
  state.drops.push(drop);
}

// ---- DROPS ----
function getInvKeyForType(type) {
  if (type === 'core') return 'cores';
  if (type === 'sub') return 'subs';
  return 'modules';
}

function spawnDrop(x, y, guaranteed) {
  const rarity = guaranteed ? pickWeighted(RARITIES, [5, 15, 35, 30, 15, 1]) : pickWeighted(RARITIES, RARITY_WEIGHTS);
  const item = makeItem(rarity, state.mapLv);
  const invKey = getInvKeyForType(item.type);
  if (state.inventories[invKey].length >= MAX_INVENTORY) return;

  const drop = {
    id: item.id,
    x: x + rand(-20, 20),
    y: y + rand(-10, 10),
    item,
    ttl: 10,
    el: null,
  };

  const el = document.createElement('div');
  el.className = 'drop ' + rarity;
  const typeTag = item.type === 'core' ? 'C' : item.type === 'sub' ? 'S' : 'M';
  el.textContent = `[${typeTag}:iL${item.ilv} ${item.name}]`;
  el.style.left = drop.x + 'px';
  el.style.top = drop.y + 'px';
  el.addEventListener('mouseenter', () => {
    pickupDrop(drop);
  });
  canvas.appendChild(el);
  drop.el = el;
  state.drops.push(drop);
}

const RARITY_SELL_MULT = { common: 1, uncommon: 2, rare: 5, epic: 10, legendary: 25, unique: 100 };

function shouldAutoSell(item) {
  const f = state.autoSellFilter;
  const rarityIdx = RARITIES.indexOf(item.rarity);
  const minRarityIdx = RARITIES.indexOf(f.minRarity);
  if (item.ilv < f.minIlv || rarityIdx < minRarityIdx) return true;
  return false;
}

function autoSellItem(item) {
  const sellPrice = item.ilv * (RARITY_SELL_MULT[item.rarity] || 1);
  state.credits += sellPrice;
}

function pickupDrop(drop) {
  // Auto sell filter check
  if (shouldAutoSell(drop.item)) {
    autoSellItem(drop.item);
    if (drop.el) drop.el.remove();
    state.drops = state.drops.filter(d => d.id !== drop.id);
    updateHUD();
    return;
  }
  const invKey = getInvKeyForType(drop.item.type);
  if (state.inventories[invKey].length >= MAX_INVENTORY) return;
  playDropSound(drop.item.rarity);
  state.inventories[invKey].push(drop.item);
  if (drop.el) drop.el.remove();
  state.drops = state.drops.filter(d => d.id !== drop.id);
  renderInventory();
}

function updateDrops(dt) {
  for (const d of [...state.drops]) {
    d.ttl -= dt;
    if (d.ttl <= 0) {
      if (d.el) d.el.remove();
      state.drops = state.drops.filter(dd => dd.id !== d.id);
    } else if (d.ttl < 3) {
      if (d.el) d.el.style.opacity = d.ttl / 3;
    }
  }
}

// ---- EQUIP / UNEQUIP ----
function showBanner(text) {
  const banner = document.getElementById('status-banner');
  banner.textContent = text;
  banner.style.display = 'block';
  setTimeout(() => { banner.style.display = 'none'; }, 1500);
}

function getSlotsForType(type) {
  if (type === 'core') return state.equipped.cores;
  if (type === 'sub') return state.equipped.subs;
  return state.equipped.modules;
}

function equipItem(item) {
  const slots = getSlotsForType(item.type);
  const emptyIdx = slots.indexOf(null);
  if (emptyIdx === -1) {
    playNote(200, 'square', 0.06, 0.1);
    showBanner('NO EMPTY ' + item.type.toUpperCase() + ' SLOT');
    return;
  }
  slots[emptyIdx] = item;
  playEquipSound();
  const invKey = getInvKeyForType(item.type);
  state.inventories[invKey] = state.inventories[invKey].filter(i => i.id !== item.id);
  if (item.type === 'sub') rebuildDrones();
  renderInventory();
  updateHUD();
}

function unequipSlot(type, idx) {
  const slots = getSlotsForType(type);
  const item = slots[idx];
  if (!item) return;
  const invKey = getInvKeyForType(type);
  if (state.inventories[invKey].length >= MAX_INVENTORY) {
    showBanner('INVENTORY FULL');
    return;
  }
  slots[idx] = null;
  state.inventories[invKey].push(item);
  if (type === 'sub') rebuildDrones();
  renderInventory();
  updateHUD();
}

function trashItem(item) {
  const invKey = getInvKeyForType(item.type);
  state.inventories[invKey] = state.inventories[invKey].filter(i => i.id !== item.id);
  renderInventory();
}

// ---- TOOLTIP ----
const tooltipEl = document.getElementById('item-tooltip');
function showTooltip(item, ev) {
  let html = `<div class="tt-name">${item.name}</div>`;
  const archLabel = item.archetype && ARCHETYPES[item.archetype]
    ? ` | <span style="color:${ARCHETYPES[item.archetype].color}">${ARCHETYPES[item.archetype].label}</span>`
    : '';
  html += `<div class="tt-type">${item.type.toUpperCase()} | iLv ${item.ilv} | ${item.rarity.toUpperCase()}${archLabel}</div>`;
  if (item.type === 'core') {
    html += `<div class="tt-stats">ATK: ${item.atk} | Splash: ${item.splash} | CD: ${item.cd}s</div>`;
    html += `<div class="tt-shape">Shape: ${(item.attackShape || 'circle').toUpperCase()}</div>`;
  } else if (item.type === 'sub') {
    html += `<div class="tt-stats">ATK: ${item.atk}</div>`;
    html += `<div class="tt-auto">Auto: ${(item.autoMode || 'nearest').toUpperCase()}</div>`;
  }
  if (item.affixes && item.affixes.length > 0) {
    html += '<div class="tt-affix">';
    for (const af of item.affixes) {
      html += af.label(af.value) + '<br>';
    }
    html += '</div>';
  }
  tooltipEl.innerHTML = html;
  tooltipEl.className = 'item-tooltip ' + item.rarity;
  tooltipEl.style.display = 'block';
  positionTooltip(ev);
}
function positionTooltip(ev) {
  let x = ev.clientX + 12;
  let y = ev.clientY + 12;
  if (x + 260 > window.innerWidth) x = ev.clientX - 260;
  if (y + 150 > window.innerHeight) y = ev.clientY - 150;
  tooltipEl.style.left = x + 'px';
  tooltipEl.style.top = y + 'px';
}
function hideTooltip() {
  tooltipEl.style.display = 'none';
}

// ---- RENDER INVENTORY ----
function renderInventory() {
  const coreContainer = document.getElementById('core-slots');
  const subContainer = document.getElementById('sub-slots');
  const modContainer = document.getElementById('module-slots');
  coreContainer.innerHTML = '';
  subContainer.innerHTML = '';
  modContainer.innerHTML = '';

  function renderSlots(container, slots, type, prefix) {
    for (let i = 0; i < 4; i++) {
      const item = slots[i];
      const slot = document.createElement('div');
      slot.className = 'equip-slot ' + (item ? item.rarity : 'empty');
      let extra = '';
      if (item && item.type === 'core' && item.attackShape) extra = ` [${item.attackShape[0].toUpperCase()}]`;
      if (item && item.type === 'sub' && item.autoMode) extra = ` [${item.autoMode[0].toUpperCase()}]`;
      slot.innerHTML = `<span class="slot-label">${prefix}${i+1}</span><span class="slot-item">${item ? '[iL' + item.ilv + '] ' + item.name + extra : '— empty —'}</span>`;
      if (item) {
        slot.addEventListener('click', () => unequipSlot(type, i));
        slot.addEventListener('mouseenter', (ev) => showTooltip(item, ev));
        slot.addEventListener('mousemove', positionTooltip);
        slot.addEventListener('mouseleave', hideTooltip);
      }
      container.appendChild(slot);
    }
  }
  renderSlots(coreContainer, state.equipped.cores, 'core', 'C');
  renderSlots(subContainer, state.equipped.subs, 'sub', 'S');
  renderSlots(modContainer, state.equipped.modules, 'module', 'M');

  // Render each genre inventory with paging
  renderInvSection('core', state.inventories.cores, 'inv-list-core', 'inv-page-core', 'inv-count-core', 'cores');
  renderInvSection('sub', state.inventories.subs, 'inv-list-sub', 'inv-page-sub', 'inv-count-sub', 'subs');
  renderInvSection('module', state.inventories.modules, 'inv-list-mod', 'inv-page-mod', 'inv-count-mod', 'modules');

  // Add AUTO EQUIP buttons
  addAutoEquipBtn('inv-page-core', 'core');
  addAutoEquipBtn('inv-page-sub', 'sub');
  addAutoEquipBtn('inv-page-mod', 'module');

  // Render forge options
  renderForge();
}

function addAutoEquipBtn(containerId, type) {
  const container = document.getElementById(containerId);
  const btn = document.createElement('button');
  btn.className = 'inv-page-btn';
  btn.textContent = 'AUTO EQUIP';
  btn.style.marginLeft = '6px';
  btn.addEventListener('click', (ev) => { ev.stopPropagation(); autoEquip(type); });
  btn.addEventListener('mousedown', (ev) => ev.stopPropagation());
  container.appendChild(btn);
}

function autoEquip(type) {
  const slots = getSlotsForType(type);
  const invKey = getInvKeyForType(type);
  // Collect all items (equipped + inventory)
  const all = [];
  for (let i = 0; i < 4; i++) {
    if (slots[i]) { all.push(slots[i]); slots[i] = null; }
  }
  all.push(...state.inventories[invKey]);

  // Sort by priority
  if (type === 'core') {
    all.sort((a, b) => b.atk - a.atk || b.ilv - a.ilv);
  } else if (type === 'sub') {
    all.sort((a, b) => b.atk - a.atk || b.ilv - a.ilv);
  } else {
    // module: affix count desc, then ilv desc
    all.sort((a, b) => (b.affixes ? b.affixes.length : 0) - (a.affixes ? a.affixes.length : 0) || b.ilv - a.ilv);
  }

  // Equip top 4, rest to inventory
  const toEquip = all.splice(0, 4);
  for (let i = 0; i < 4; i++) slots[i] = toEquip[i] || null;
  state.inventories[invKey] = all;

  if (type === 'sub') rebuildDrones();
  playEquipSound();
  renderInventory();
  updateHUD();
}

function renderInvSection(type, items, listId, pageId, countId, pageKey) {
  const container = document.getElementById(listId);
  const pageContainer = document.getElementById(pageId);
  document.getElementById(countId).textContent = items.length;
  container.innerHTML = '';
  pageContainer.innerHTML = '';

  const totalPages = Math.max(1, Math.ceil(items.length / INV_PAGE_SIZE));
  if (state.invPages[pageKey] >= totalPages) state.invPages[pageKey] = Math.max(0, totalPages - 1);
  const page = state.invPages[pageKey];
  const start = page * INV_PAGE_SIZE;
  const end = Math.min(start + INV_PAGE_SIZE, items.length);

  for (let i = start; i < end; i++) {
    const item = items[i];
    const row = document.createElement('div');
    row.className = 'inv-item ' + item.rarity;
    row.innerHTML = `<span class="inv-name">[iL${item.ilv}] ${item.name}</span><span class="inv-trash">x</span>`;
    row.querySelector('.inv-name').addEventListener('click', (ev) => { ev.stopPropagation(); equipItem(item); });
    row.querySelector('.inv-trash').addEventListener('click', (ev) => { ev.stopPropagation(); trashItem(item); });
    row.addEventListener('mouseenter', (ev) => showTooltip(item, ev));
    row.addEventListener('mousemove', positionTooltip);
    row.addEventListener('mouseleave', hideTooltip);
    container.appendChild(row);
  }

  if (items.length > INV_PAGE_SIZE) {
    const prevBtn = document.createElement('button');
    prevBtn.className = 'inv-page-btn';
    prevBtn.textContent = '<';
    prevBtn.disabled = page === 0;
    prevBtn.addEventListener('click', (ev) => { ev.stopPropagation(); state.invPages[pageKey]--; renderInventory(); });
    prevBtn.addEventListener('mousedown', (ev) => ev.stopPropagation());

    const pageLabel = document.createElement('span');
    pageLabel.textContent = `${page + 1}/${totalPages}`;

    const nextBtn = document.createElement('button');
    nextBtn.className = 'inv-page-btn';
    nextBtn.textContent = '>';
    nextBtn.disabled = page >= totalPages - 1;
    nextBtn.addEventListener('click', (ev) => { ev.stopPropagation(); state.invPages[pageKey]++; renderInventory(); });
    nextBtn.addEventListener('mousedown', (ev) => ev.stopPropagation());

    pageContainer.appendChild(prevBtn);
    pageContainer.appendChild(pageLabel);
    pageContainer.appendChild(nextBtn);
  }
}

// ---- LEVEL UP ----
const SKILL_POOL = [
  { id: 'atk', name: 'ATK +20%', baseCost: 10, maxLv: 100, apply: () => { state.upgrades.atkMult += 0.2; } },
  { id: 'cd', name: 'CD -10%', baseCost: 10, maxLv: 5, apply: () => { state.upgrades.cdMult = Math.max(0.5, state.upgrades.cdMult * 0.9); } },
  { id: 'splash', name: 'Splash +20%', baseCost: 20, maxLv: 5, apply: () => { state.upgrades.splashMult = Math.min(2.0, state.upgrades.splashMult + 0.2); } },
  { id: 'crit', name: 'Crit +10%', baseCost: 15, maxLv: 8, apply: () => { state.upgrades.critChance = Math.min(0.8, state.upgrades.critChance + 0.1); } },
  { id: 'critdmg', name: 'CritDMG +50%', baseCost: 25, maxLv: 50, apply: () => { state.upgrades.critMult += 0.5; } },
  { id: 'credits', name: 'Credits +15%', baseCost: 15, maxLv: 50, apply: () => { state.upgrades.creditMult += 0.15; } },
  { id: 'droprate', name: 'Drop +20%', baseCost: 30, maxLv: 30, apply: () => { state.upgrades.dropMult += 0.2; } },
  { id: 'alldmg', name: 'ALL DMG +25%', baseCost: 50, maxLv: 50, apply: () => { state.upgrades.allDmgMult = (state.upgrades.allDmgMult || 1) + 0.25; } },
  { id: 'subatk', name: 'SUB ATK +20%', baseCost: 20, maxLv: 50, apply: () => { state.upgrades.subAtkMult = (state.upgrades.subAtkMult || 1) + 0.2; } },
];

function getSkillCost(skill) {
  const lv = state.skillLevels[skill.id] || 0;
  return Math.floor(skill.baseCost * Math.pow(1.15, lv));
}

function renderUpgradePanel() {
  const container = document.getElementById('upgrade-list');
  document.getElementById('hud-credits-panel').textContent = state.credits;
  container.innerHTML = '';
  for (const skill of SKILL_POOL) {
    const lv = state.skillLevels[skill.id] || 0;
    const cost = getSkillCost(skill);
    const canBuy = state.credits >= cost && lv < skill.maxLv;
    const row = document.createElement('div');
    row.className = 'upgrade-row';
    row.innerHTML = `<span>${skill.name} (${lv}/${skill.maxLv})</span>`;
    const btn = document.createElement('button');
    btn.className = 'upgrade-btn';
    btn.textContent = `[¢${cost}]`;
    btn.disabled = !canBuy;
    btn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const currentCost = getSkillCost(skill);
      if (state.credits >= currentCost && (state.skillLevels[skill.id] || 0) < skill.maxLv) {
        state.credits -= currentCost;
        state.skillLevels[skill.id] = (state.skillLevels[skill.id] || 0) + 1;
        skill.apply();
        renderUpgradePanel();
        updateHUD();
      }
    });
    row.appendChild(btn);
    container.appendChild(row);
  }
}

// ---- HUD ----
function updateHUD() {
  document.getElementById('maplv-select').value = state.mapLv;
  document.getElementById('hud-credits').textContent = state.credits;
  document.getElementById('hud-score').textContent = state.score;
  document.getElementById('hud-kills').textContent = state.kills;

  const stats = getComputedStats();
  document.getElementById('hud-cores').textContent = stats.coreCount;
  document.getElementById('hud-atk').textContent = stats.atk;
  const splashEl = document.getElementById('hud-splash');
  splashEl.textContent = stats.splash;
  splashEl.style.color = stats.splash >= 200 ? '#ffaa00' : '';
  document.getElementById('hud-cd').textContent = stats.cd.toFixed(2);
  const critEl = document.getElementById('hud-crit');
  critEl.textContent = Math.floor(stats.critChance * 100);
  critEl.style.color = stats.critChance >= 0.75 ? '#ffaa00' : '';
  const critDmgEl = document.getElementById('hud-critdmg');
  critDmgEl.textContent = stats.critDmg.toFixed(1);
  critDmgEl.style.color = stats.critDmg >= 10 ? '#ffaa00' : '';

  // Synergy display
  const synEl = document.getElementById('hud-synergy');
  const synParts = [];
  if (stats.synergyCounts) {
    for (const [key, count] of Object.entries(stats.synergyCounts)) {
      if (count >= 2) {
        const arch = ARCHETYPES[key];
        synParts.push(`<span style="color:${arch.color}">${arch.label}(${count})</span>`);
      }
    }
  }
  synEl.innerHTML = synParts.length > 0 ? 'SYN:' + synParts.join(' ') : '';

  updateCrosshair();
}

// ---- ORBIT RENDERING ----
let orbitMarkers = [null, null, null, null];
function updateOrbitVisuals() {
  for (let i = 0; i < 4; i++) {
    const sub = state.equipped.subs[i];
    if (sub && sub.autoMode === 'orbit') {
      if (!orbitMarkers[i]) {
        const m = document.createElement('div');
        m.className = 'orbit-marker';
        canvas.appendChild(m);
        orbitMarkers[i] = m;
      }
      const angle = state.orbitAngles[i] || 0;
      const ox = state.mouseX + Math.cos(angle) * 150;
      const oy = state.mouseY + Math.sin(angle) * 150;
      orbitMarkers[i].style.left = (ox - 4) + 'px';
      orbitMarkers[i].style.top = (oy - 4) + 'px';
    } else {
      if (orbitMarkers[i]) {
        orbitMarkers[i].remove();
        orbitMarkers[i] = null;
      }
    }
  }
}

// ---- INFECTION (parasite DoT) ----
function updateInfections(dt) {
  const toRemove = [];
  for (let i = state.infections.length - 1; i >= 0; i--) {
    const inf = state.infections[i];
    inf.ttl -= dt;
    if (inf.ttl <= 0) { state.infections.splice(i, 1); continue; }
    const enemy = state.enemies.find(e => e.id === inf.enemyId);
    if (!enemy) { state.infections.splice(i, 1); continue; }
    const dmg = Math.max(1, Math.floor(inf.dmgPerSec * dt));
    applyDamage(enemy, dmg);
    if (Math.random() < dt * 2) showDamageNumber(enemy.x, enemy.y, dmg, false, true, null, 'parasite');
    if (enemy.hp <= 0) {
      // Propagate before kill
      const ec = getEnemyCenter(enemy);
      let closest = null, cDist = Infinity;
      for (const e of state.enemies) {
        if (e.id === enemy.id) continue;
        const eec = getEnemyCenter(e);
        const d = dist(ec.x, ec.y, eec.x, eec.y);
        if (d < 60 && d < cDist) { cDist = d; closest = e; }
      }
      if (closest) {
        // Check max infections for this sub
        const myCount = state.infections.filter(x => x.subIdx === inf.subIdx).length;
        if (myCount <= 3) { // will be reduced by 1 after splice
          state.infections.push({ enemyId: closest.id, subIdx: inf.subIdx, dmgPerSec: inf.dmgPerSec, ttl: 5 });
          const cec = getEnemyCenter(closest);
          showSubEffect(cec.x, cec.y, '[P]');
          playSubSound('parasite');
        }
      }
      state.infections.splice(i, 1);
      killEnemy(enemy, true);
    }
  }
}

// ---- DRONES ----
function rebuildDrones() {
  // Remove old drone DOMs
  for (const d of state.drones) { if (d.el) d.el.remove(); }
  state.drones = [];
  let count = 0;
  for (let i = 0; i < 4; i++) {
    const sub = state.equipped.subs[i];
    if (sub && sub.autoMode === 'drone' && count < 4) {
      const el = document.createElement('div');
      el.style.cssText = 'position:absolute;color:#00ff88;font-size:14px;font-weight:bold;pointer-events:none;z-index:49;text-shadow:0 0 6px #00ff88;';
      el.textContent = '[D]';
      canvas.appendChild(el);
      state.drones.push({ x: state.mouseX + rand(-50,50), y: state.mouseY + rand(-50,50), subIdx: i, cooldown: 0, el });
      count++;
    }
  }
}

function updateDrones(dt) {
  const stats = getComputedStats();
  for (const d of state.drones) {
    // Lerp toward cursor
    d.x += (state.mouseX - d.x) * 0.03;
    d.y += (state.mouseY - d.y) * 0.03;
    d.el.style.left = (d.x - 10) + 'px';
    d.el.style.top = (d.y - 7) + 'px';
    d.cooldown = Math.max(0, d.cooldown - dt);
    if (d.cooldown > 0) continue;
    // Find nearest enemy within 100px
    let nearest = null, nDist = Infinity;
    for (const e of state.enemies) {
      const ec = getEnemyCenter(e);
      const dd = dist(d.x, d.y, ec.x, ec.y);
      if (dd < 100 && dd < nDist) { nDist = dd; nearest = e; }
    }
    if (nearest) {
      const sub = state.equipped.subs[d.subIdx];
      if (!sub) continue;
      const subBase = sub.atk * getSubDmgMult();
      const isCrit = Math.random() < stats.critChance;
      const dmg = Math.floor(isCrit ? subBase * stats.critDmg : subBase);
      applyDamage(nearest, dmg);
      showDamageNumber(nearest.x, nearest.y, dmg, isCrit, true, null, 'drone');
      const ec = getEnemyCenter(nearest);
      showSubEffect(ec.x, ec.y, '·');
      playSubSound('drone');
      d.cooldown = 0.8;
      if (nearest.hp <= 0) killEnemy(nearest, true);
    }
  }
}

// ---- BULK SELL ----
function bulkSell() {
  let totalSold = 0;
  for (const key of ['cores', 'subs', 'modules']) {
    const kept = [];
    for (const item of state.inventories[key]) {
      if (shouldAutoSell(item)) {
        autoSellItem(item);
        totalSold++;
      } else {
        kept.push(item);
      }
    }
    state.inventories[key] = kept;
  }
  if (totalSold > 0) showBanner('SOLD ' + totalSold + ' ITEMS');
  renderInventory();
  updateHUD();
}

// ---- FORGE SYSTEM ----
function getForgeOptions() {
  const options = [];
  for (const invKey of ['cores', 'subs', 'modules']) {
    const items = state.inventories[invKey];
    // Group by archetype + rarity
    const groups = {};
    for (const item of items) {
      if (!item.archetype) continue;
      if (item.rarity === 'unique') continue; // can't forge uniques
      const key = `${item.archetype}|${item.rarity}|${invKey}`;
      if (!groups[key]) groups[key] = [];
      groups[key].push(item);
    }
    for (const [key, group] of Object.entries(groups)) {
      if (group.length >= 3) {
        const [archetype, rarity, type] = key.split('|');
        const rarityIdx = RARITIES.indexOf(rarity);
        if (rarityIdx < RARITIES.length - 2) { // can't forge to unique via forge
          options.push({
            archetype, rarity, type,
            nextRarity: RARITIES[rarityIdx + 1],
            items: group,
          });
        }
      }
    }
  }
  return options;
}

function forgeItems(option) {
  // Consume first 3 items
  const toConsume = option.items.slice(0, 3);
  const invKey = option.type;
  for (const item of toConsume) {
    state.inventories[invKey] = state.inventories[invKey].filter(i => i.id !== item.id);
  }
  // Generate new item of next rarity with matching archetype
  const avgIlv = Math.floor(toConsume.reduce((s, i) => s + i.ilv, 0) / 3);
  const newItem = makeItem(option.nextRarity, avgIlv);
  newItem.archetype = option.archetype; // force archetype match
  state.inventories[invKey].push(newItem);
  playEquipSound();
  showBanner('FORGED: ' + newItem.name);
  renderInventory();
  updateHUD();
}

function renderForge() {
  const container = document.getElementById('forge-options');
  container.innerHTML = '';
  const options = getForgeOptions();
  if (options.length === 0) {
    container.innerHTML = '<div style="color:#555;font-size:10px;">No forge available</div>';
    return;
  }
  for (const opt of options) {
    const arch = ARCHETYPES[opt.archetype];
    const btn = document.createElement('button');
    btn.className = 'upgrade-btn';
    btn.style.width = '100%';
    btn.style.marginBottom = '2px';
    btn.style.fontSize = '10px';
    btn.innerHTML = `<span style="color:${arch.color}">${arch.label}</span> ${opt.rarity} x3 -> ${opt.nextRarity}`;
    btn.addEventListener('click', (ev) => { ev.stopPropagation(); forgeItems(opt); });
    btn.addEventListener('mousedown', (ev) => ev.stopPropagation());
    container.appendChild(btn);
  }
}

// ---- DPS TRACKING ----
function logDamage(dmg) {
  state.dpsLog.push({ time: performance.now(), dmg });
}
function logKill() {
  state.killLog.push({ time: performance.now() });
}
function logCredits(amount) {
  state.creditLog.push({ time: performance.now(), amount });
}

function updateDpsPanel() {
  const now = performance.now();
  const window5s = 5000;
  state.dpsLog = state.dpsLog.filter(e => now - e.time < window5s);
  state.killLog = state.killLog.filter(e => now - e.time < window5s);
  state.creditLog = state.creditLog.filter(e => now - e.time < window5s);

  const totalDmg = state.dpsLog.reduce((s, e) => s + e.dmg, 0);
  const dps = Math.floor(totalDmg / (window5s / 1000));
  const kps = (state.killLog.length / (window5s / 1000)).toFixed(1);
  const totalCr = state.creditLog.reduce((s, e) => s + e.amount, 0);
  const cps = Math.floor(totalCr / (window5s / 1000));

  document.getElementById('dps-value').textContent = dps;
  document.getElementById('kps-value').textContent = kps;
  document.getElementById('cps-value').textContent = cps;
}

// ---- MILESTONES ----
function checkMilestone() {
  if (state.score >= state.milestoneNext) {
    showBanner('MILESTONE: ' + state.milestoneNext + ' SCORE');
    // Next milestone doubles
    state.milestoneNext = state.milestoneNext * 2;
  }
}

// ---- MAIN LOOP ----
let lastTime = 0;
let dpsUpdateTimer = 0;
function gameLoop(timestamp) {
  if (!state.running) return;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;

  if (!state.paused) {
    if (state.cooldown > 0) state.cooldown = Math.max(0, state.cooldown - dt);

    if (mouseDown && state.cooldown <= 0) {
      if (state.mouseY >= CANVAS_PAD_TOP && state.mouseY <= window.innerHeight - CANVAS_PAD_BOT) {
        attack(state.mouseX, state.mouseY);
      }
    }

    state.spawnTimer += dt;
    if (state.spawnTimer >= SPAWN_INTERVAL && state.enemies.length < getMaxEnemies()) {
      state.spawnTimer = 0;
      spawnEnemy();
    }

    updateEnemies(dt);
    updateDrops(dt);
    updateSubAttacks(dt);
    updateOrbitVisuals();
    updateInfections(dt);
    updateDrones(dt);
  }

  dpsUpdateTimer += dt;
  if (dpsUpdateTimer > 0.5) { dpsUpdateTimer = 0; updateDpsPanel(); }
  updateHUD();
  requestAnimationFrame(gameLoop);
}

// ---- INPUT ----
let mouseDown = false;
const crosshairEl = document.getElementById('crosshair');
document.addEventListener('mousemove', (e) => {
  state.mouseX = e.clientX;
  state.mouseY = e.clientY;
  crosshairEl.style.left = e.clientX + 'px';
  crosshairEl.style.top = e.clientY + 'px';
});
function updateCrosshair() {
  const stats = getComputedStats();
  // Find primary core shape and max splash
  let primaryShape = 'circle';
  let maxSplash = 0;
  for (const c of state.equipped.cores) {
    if (c) {
      const s = Math.floor(c.splash * state.upgrades.splashMult);
      if (s > maxSplash) maxSplash = s;
      if (primaryShape === 'circle') primaryShape = c.attackShape || 'circle';
    }
  }
  const splash = maxSplash || stats.splash;
  // Remove old shape classes
  crosshairEl.className = '';
  let w, h;
  switch (primaryShape) {
    case 'line':
      crosshairEl.classList.add('shape-line');
      w = 30; h = splash * 3;
      break;
    case 'cone':
      crosshairEl.classList.add('shape-cone');
      w = splash * 1.5; h = splash * 1.5;
      break;
    case 'nova':
      crosshairEl.classList.add('shape-nova');
      w = splash * 4; h = splash * 4;
      break;
    case 'pierce-burst':
      crosshairEl.classList.add('shape-pierce-burst');
      w = 40; h = splash * 2.5;
      break;
    case 'lock-on':
      crosshairEl.classList.add('shape-lock-on');
      w = splash * 2; h = splash * 2;
      break;
    default: // circle
      w = splash * 2; h = splash * 2;
      break;
  }
  crosshairEl.style.width = w + 'px';
  crosshairEl.style.height = h + 'px';
}
document.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;
  mouseDown = true;
});
document.addEventListener('mouseup', (e) => {
  if (e.button === 0) mouseDown = false;
});

// Populate MapLv select (1-100)
const mapLvSelect = document.getElementById('maplv-select');
for (let i = 1; i <= 999; i++) {
  const opt = document.createElement('option');
  opt.value = i;
  opt.textContent = i;
  mapLvSelect.appendChild(opt);
}
mapLvSelect.value = state.mapLv;
mapLvSelect.addEventListener('change', (ev) => {
  ev.stopPropagation();
  state.mapLv = parseInt(mapLvSelect.value);
  clearAllEnemies();
  const initial = Math.min(getMaxEnemies(), getMaxEnemies());
  for (let i = 0; i < initial; i++) spawnEnemy();
  updateHUD();
});
mapLvSelect.addEventListener('mousedown', (ev) => { ev.stopPropagation(); });

function clearAllEnemies() {
  for (const e of state.enemies) {
    if (e.el) e.el.remove();
  }
  state.enemies = [];
  // Also clear ground drops
  for (const d of state.drops) {
    if (d.el) d.el.remove();
  }
  state.drops = [];
}

// ---- START ----
// ---- SAVE / LOAD ----
const SAVE_KEY = 'hacksim_save';
const SAVE_VERSION = 1;

function saveGame() {
  const data = {
    version: SAVE_VERSION,
    mapLv: state.mapLv,
    score: state.score,
    kills: state.kills,
    credits: state.credits,
    equipped: state.equipped,
    inventories: state.inventories,
    upgrades: state.upgrades,
    skillLevels: state.skillLevels,
    autoSellFilter: state.autoSellFilter,
  };
  localStorage.setItem(SAVE_KEY, JSON.stringify(data));
}

function loadGame() {
  const raw = localStorage.getItem(SAVE_KEY);
  if (!raw) return false;
  try {
    const data = JSON.parse(raw);
    if (data.version !== SAVE_VERSION) return false;
    state.mapLv = data.mapLv || 1;
    state.score = data.score || 0;
    state.kills = data.kills || 0;
    state.credits = data.credits || 0;
    state.equipped = data.equipped || { cores: [null,null,null,null], subs: [null,null,null,null], modules: [null,null,null,null] };
    state.inventories = data.inventories || { cores: [], subs: [], modules: [] };
    state.upgrades = data.upgrades || state.upgrades;
    state.skillLevels = data.skillLevels || {};
    state.autoSellFilter = data.autoSellFilter || { minIlv: 0, minRarity: 'common' };
    // Ensure new upgrade fields exist
    if (!state.upgrades.allDmgMult) state.upgrades.allDmgMult = 1;
    if (!state.upgrades.subAtkMult) state.upgrades.subAtkMult = 1;
    return true;
  } catch (e) {
    return false;
  }
}

function resetGame() {
  localStorage.removeItem(SAVE_KEY);
  location.reload();
}

// Auto-save every 30 seconds
setInterval(saveGame, 30000);

// Auto sell filter UI
document.getElementById('autosell-ilv').addEventListener('input', (ev) => {
  ev.stopPropagation();
  state.autoSellFilter.minIlv = parseInt(ev.target.value) || 0;
  saveGame();
});
document.getElementById('autosell-ilv').addEventListener('mousedown', (ev) => ev.stopPropagation());
document.getElementById('autosell-rarity').addEventListener('change', (ev) => {
  ev.stopPropagation();
  state.autoSellFilter.minRarity = ev.target.value;
  saveGame();
});
document.getElementById('autosell-rarity').addEventListener('mousedown', (ev) => ev.stopPropagation());

function syncAutoSellUI() {
  document.getElementById('autosell-ilv').value = state.autoSellFilter.minIlv;
  document.getElementById('autosell-rarity').value = state.autoSellFilter.minRarity;
}

function init() {
  const loaded = loadGame();
  if (!loaded) {
    state.equipped.cores[0] = {
      id: 0,
      type: 'core',
      name: 'Ping Flood',
      rarity: 'common',
      ilv: 1,
      atk: 10,
      splash: 50,
      cd: 0.5,
      affixes: [],
      attackShape: 'circle',
      archetype: 'area',
    };
  }
  state.running = true;
  lastTime = performance.now();
  const initial = Math.min(getMaxEnemies(), 12);
  for (let i = 0; i < initial; i++) spawnEnemy();
  syncAutoSellUI();
  renderUpgradePanel();
  renderInventory();
  updateHUD();
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
