<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>HACK.SIM</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #0a0a0a;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  cursor: none;
  user-select: none;
}
#game-canvas {
  position: relative;
  width: 100vw;
  height: 100vh;
}

/* HUD */
#hud {
  position: fixed;
  top: 0; left: 0; right: 0;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(0,0,0,0.8);
  border-bottom: 1px solid #00ff41;
  z-index: 100;
  font-size: 14px;
}
#hud .trace-bar {
  width: 200px;
  height: 14px;
  border: 1px solid #00ff41;
  position: relative;
}
#hud .trace-fill {
  height: 100%;
  background: #00ff41;
  transition: width 0.3s;
}
#hud .trace-bar.danger { border-color: #ff4444; }
#hud .trace-bar.danger .trace-fill { background: #ff4444; }

/* Bottom HUD */
#bottom-hud {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  background: rgba(0,0,0,0.8);
  border-top: 1px solid #00ff41;
  z-index: 100;
  font-size: 13px;
}

/* Inventory panel (left side) */
#inventory-panel {
  position: fixed;
  top: 50px;
  left: 10px;
  width: 230px;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
  background: rgba(0,0,0,0.85);
  border: 1px solid #00ff41;
  padding: 8px;
  z-index: 100;
  font-size: 12px;
}
#inventory-panel h3 {
  color: #ffaa00;
  font-size: 13px;
  margin-bottom: 6px;
  text-align: center;
}
.inv-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 2px 0;
  padding: 3px 4px;
  border: 1px solid transparent;
  cursor: pointer;
}
.inv-item:hover { border-color: #00ff41; }
.inv-item.equipped { border-color: #ffaa00; background: rgba(255,170,0,0.1); }
.inv-item .inv-name { flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.inv-item .inv-stats { font-size: 10px; color: #888; margin-left: 4px; white-space: nowrap; }
.inv-item .inv-trash {
  margin-left: 4px;
  color: #ff4444;
  cursor: pointer;
  font-size: 11px;
}
.inv-item .inv-trash:hover { color: #ff8888; }
.inv-item.common .inv-name { color: #aaa; }
.inv-item.uncommon .inv-name { color: #00ff41; }
.inv-item.rare .inv-name { color: #4488ff; }
.inv-item.epic .inv-name { color: #aa44ff; }
.inv-item.legendary .inv-name { color: #ffaa00; text-shadow: 0 0 4px #ffaa00; }

/* Enemies */
.enemy {
  position: absolute;
  text-align: center;
  transition: opacity 0.2s;
  pointer-events: none;
}
.enemy .label {
  font-size: 14px;
  font-weight: bold;
  white-space: nowrap;
}
.enemy .hitbox {
  position: absolute;
  top: -4px;
  left: 50%;
  width: 20px;
  height: 20px;
  transform: translateX(-50%);
  border: 1px solid rgba(0,255,65,0.25);
  border-radius: 50%;
  pointer-events: none;
}
.enemy.elite .hitbox {
  border-color: rgba(255,170,0,0.3);
}
.enemy .hp-bar {
  width: 100%;
  height: 3px;
  background: #333;
  margin-top: 2px;
}
.enemy .hp-fill {
  height: 100%;
  background: #00ff41;
  transition: width 0.15s;
}
.enemy.elite .label { color: #ffaa00; }
.enemy.elite .hp-fill { background: #ffaa00; }

/* Attack effect */
.attack-effect {
  position: absolute;
  color: #00ff41;
  font-size: 18px;
  font-weight: bold;
  pointer-events: none;
  animation: attackPop 0.4s ease-out forwards;
  z-index: 50;
}
@keyframes attackPop {
  0% { opacity: 1; transform: scale(1); }
  100% { opacity: 0; transform: scale(2); }
}

/* Damage numbers */
.damage-number {
  position: absolute;
  font-size: 16px;
  font-weight: bold;
  color: #ff4444;
  pointer-events: none;
  animation: floatUp 0.8s ease-out forwards;
  z-index: 50;
}
.damage-number.crit { font-size: 22px; color: #ffaa00; }
@keyframes floatUp {
  0% { opacity: 1; transform: translateY(0); }
  100% { opacity: 0; transform: translateY(-40px); }
}

/* Drops */
.drop {
  position: absolute;
  font-size: 12px;
  padding: 2px 6px;
  border: 1px solid;
  cursor: pointer;
  animation: dropBounce 0.3s ease-out;
  z-index: 30;
}
.drop.common { color: #aaa; border-color: #aaa; }
.drop.uncommon { color: #00ff41; border-color: #00ff41; }
.drop.rare { color: #4488ff; border-color: #4488ff; }
.drop.epic { color: #aa44ff; border-color: #aa44ff; }
.drop.legendary { color: #ffaa00; border-color: #ffaa00; text-shadow: 0 0 8px #ffaa00; }
@keyframes dropBounce {
  0% { transform: translateY(-20px); opacity: 0; }
  100% { transform: translateY(0); opacity: 1; }
}

/* Upgrade panel (right side) */
#upgrade-panel {
  position: fixed;
  top: 50px;
  right: 10px;
  width: 220px;
  background: rgba(0,0,0,0.85);
  border: 1px solid #00ff41;
  padding: 8px;
  z-index: 100;
  font-size: 12px;
}
#upgrade-panel h3 {
  color: #ffaa00;
  font-size: 13px;
  margin-bottom: 6px;
  text-align: center;
}
.upgrade-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 3px 0;
  padding: 3px 4px;
}
.upgrade-btn {
  background: none;
  border: 1px solid #00ff41;
  color: #00ff41;
  font-family: 'Courier New', monospace;
  font-size: 11px;
  padding: 2px 8px;
  cursor: pointer;
  white-space: nowrap;
}
.upgrade-btn:hover { background: rgba(0,255,65,0.2); }
.upgrade-btn:disabled { color: #555; border-color: #555; cursor: default; }
.upgrade-btn:disabled:hover { background: none; }

/* Game over / Victory */
#result-overlay {
  display: none;
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.9);
  z-index: 300;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
#result-overlay.active { display: flex; }
#result-overlay h1 { font-size: 36px; margin-bottom: 16px; }
#result-overlay .stats { font-size: 16px; margin-bottom: 24px; text-align: center; line-height: 1.8; }
#result-overlay button {
  font-family: 'Courier New', monospace;
  font-size: 16px;
  color: #00ff41;
  background: none;
  border: 1px solid #00ff41;
  padding: 10px 30px;
  cursor: pointer;
}
#result-overlay button:hover { background: rgba(0,255,65,0.2); }

/* Crosshair + splash range indicator */
#crosshair {
  position: fixed;
  border: 1px solid rgba(0,255,65,0.4);
  border-radius: 50%;
  pointer-events: none;
  z-index: 90;
  transform: translate(-50%, -50%);
}
#crosshair::after {
  content: '+';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #00ff41;
  font-size: 16px;
  font-weight: bold;
}

/* Wave banner */
#wave-banner {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 32px;
  color: #00ff41;
  z-index: 150;
  display: none;
  text-shadow: 0 0 20px #00ff41;
}
</style>
</head>
<body>

<div id="hud">
  <div>HACK.SIM</div>
  <div>WAVE: <span id="hud-wave">1</span></div>
  <div>LV.<span id="hud-level">1</span> | XP: <span id="hud-xp">0</span>/<span id="hud-xp-max">10</span> | SP: <span id="hud-sp-top">0</span></div>
  <div>TRACE: <span id="hud-trace-pct">0</span>%
    <div class="trace-bar" id="trace-bar"><div class="trace-fill" id="trace-fill"></div></div>
  </div>
  <div>SCORE: <span id="hud-score">0</span></div>
</div>

<div id="bottom-hud">
  <div>EQUIP: <span id="hud-weapon">Ping Flood [Common]</span></div>
  <div>ATK: <span id="hud-atk">10</span> | SPLASH: <span id="hud-splash">30</span> | CD: <span id="hud-cd">0.5</span>s</div>
  <div>KILLS: <span id="hud-kills">0</span></div>
</div>

<div id="inventory-panel">
  <h3>INVENTORY [<span id="inv-count">0</span>/20]</h3>
  <div id="inv-list"></div>
</div>

<div id="game-canvas"></div>
<div id="crosshair"></div>

<div id="wave-banner"></div>

<div id="upgrade-panel">
  <h3>UPGRADES [SP: <span id="hud-sp">0</span>]</h3>
  <div id="upgrade-list"></div>
</div>

<div id="result-overlay">
  <h1 id="result-title"></h1>
  <div class="stats" id="result-stats"></div>
  <button onclick="location.reload()">[ RESTART ]</button>
</div>

<script>
// ---- CONFIG ----
const CANVAS_PAD_TOP = 40;
const CANVAS_PAD_BOT = 40;
const TRACE_PER_SEC = 0.3;
const ENEMY_TYPES = [
  { tag: 'SRV', baseHp: 20, speed: 30, xp: 2, score: 10 },
  { tag: 'NODE', baseHp: 15, speed: 45, xp: 2, score: 10 },
  { tag: 'FW', baseHp: 50, speed: 20, xp: 5, score: 30 },
  { tag: 'DB', baseHp: 80, speed: 15, xp: 8, score: 50 },
  { tag: 'PROXY', baseHp: 30, speed: 55, xp: 3, score: 20 },
];
const ELITE_TYPE = { tag: 'MAINFRAME', baseHp: 300, speed: 10, xp: 30, score: 200, elite: true };
const RARITIES = ['common','uncommon','rare','epic','legendary'];
const RARITY_WEIGHTS = [50, 30, 14, 5, 1];
const WEAPON_NAMES = [
  'Ping Flood','Port Scanner','SQL Injector','Buffer Overflow',
  'Zero-Day Exploit','Rootkit Launcher','Worm Deployer','Trojan Horse',
  'DDoS Cannon','Crypto Breaker','Firewall Piercer','Kernel Panic'
];

// ---- STATE ----
let state = {
  running: false,
  paused: false,
  wave: 1,
  waveTimer: 0,
  waveEnemiesLeft: 0,
  score: 0,
  kills: 0,
  level: 1,
  xp: 0,
  xpToNext: 10,
  trace: 0,
  enemies: [],
  drops: [],
  weapon: { id: 0, name: 'Ping Flood', rarity: 'common', atk: 10, splash: 50, cd: 0.5 },
  cooldown: 0,
  mouseX: 0,
  mouseY: 0,
  upgrades: { atkMult: 1, rangeMult: 1, cdMult: 1, traceReduce: 0, splashMult: 1, critChance: 0.05, critMult: 2 },
  waveKills: 0,
  waveKillTarget: 0,
  sp: 0,
  skillLevels: {},
  inventory: [],
  maxInventory: 20,
};

const canvas = document.getElementById('game-canvas');

// ---- UTILITIES ----
function rand(min, max) { return Math.random() * (max - min) + min; }
function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
function pickWeighted(items, weights) {
  const total = weights.reduce((a, b) => a + b, 0);
  let r = Math.random() * total;
  for (let i = 0; i < items.length; i++) { r -= weights[i]; if (r <= 0) return items[i]; }
  return items[items.length - 1];
}
function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

// ---- ENEMY MANAGEMENT ----
function spawnEnemy() {
  if (!state.running) return;
  const isElite = state.wave > 1 && Math.random() < 0.05 + state.wave * 0.01;
  const template = isElite ? ELITE_TYPE : ENEMY_TYPES[randInt(0, ENEMY_TYPES.length - 1)];
  const scaledHp = Math.floor(template.baseHp * (1 + (state.wave - 1) * 0.4));
  const w = window.innerWidth;
  const h = window.innerHeight;
  // Spawn from edges
  const side = randInt(0, 3);
  let x, y;
  if (side === 0) { x = rand(0, w); y = CANVAS_PAD_TOP; }
  else if (side === 1) { x = rand(0, w); y = h - CANVAS_PAD_BOT; }
  else if (side === 2) { x = 0; y = rand(CANVAS_PAD_TOP, h - CANVAS_PAD_BOT); }
  else { x = w; y = rand(CANVAS_PAD_TOP, h - CANVAS_PAD_BOT); }

  const enemy = {
    id: Date.now() + Math.random(),
    tag: template.tag,
    hp: scaledHp,
    maxHp: scaledHp,
    speed: template.speed + rand(-5, 5),
    xp: template.xp,
    score: template.score,
    elite: !!template.elite,
    x, y,
    el: null,
    vx: 0, vy: 0,
  };
  // random wandering direction
  const angle = Math.random() * Math.PI * 2;
  enemy.vx = Math.cos(angle) * enemy.speed;
  enemy.vy = Math.sin(angle) * enemy.speed;

  const el = document.createElement('div');
  el.className = 'enemy' + (enemy.elite ? ' elite' : '');
  el.innerHTML = `<div class="hitbox"></div><div class="label">[${enemy.tag}:${enemy.hp}]</div><div class="hp-bar"><div class="hp-fill"></div></div>`;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  canvas.appendChild(el);
  enemy.el = el;
  enemy.labelEl = el.querySelector('.label');
  enemy.hpFillEl = el.querySelector('.hp-fill');
  state.enemies.push(enemy);
}

function removeEnemy(enemy) {
  if (enemy.el) enemy.el.remove();
  state.enemies = state.enemies.filter(e => e.id !== enemy.id);
}

function updateEnemies(dt) {
  const w = window.innerWidth;
  const h = window.innerHeight;
  for (const e of state.enemies) {
    // Wander with occasional direction change
    if (Math.random() < 0.01) {
      const angle = Math.random() * Math.PI * 2;
      e.vx = Math.cos(angle) * e.speed;
      e.vy = Math.sin(angle) * e.speed;
    }
    e.x += e.vx * dt;
    e.y += e.vy * dt;
    // Bounce off edges
    if (e.x < 10) { e.x = 10; e.vx = Math.abs(e.vx); }
    if (e.x > w - 10) { e.x = w - 10; e.vx = -Math.abs(e.vx); }
    if (e.y < CANVAS_PAD_TOP + 10) { e.y = CANVAS_PAD_TOP + 10; e.vy = Math.abs(e.vy); }
    if (e.y > h - CANVAS_PAD_BOT - 10) { e.y = h - CANVAS_PAD_BOT - 10; e.vy = -Math.abs(e.vy); }
    // Update DOM
    e.el.style.left = e.x + 'px';
    e.el.style.top = e.y + 'px';
    e.labelEl.textContent = `[${e.tag}:${e.hp}]`;
    const hpPct = Math.max(0, e.hp / e.maxHp * 100);
    e.hpFillEl.style.width = hpPct + '%';
  }
}

// ---- ATTACK ----
function attack(mx, my) {
  if (state.cooldown > 0 || state.paused) return;
  const w = state.weapon;
  const atkPower = Math.floor(w.atk * state.upgrades.atkMult);
  const splash = (w.splash || 30) * state.upgrades.splashMult;

  // Show click effect
  showAttackEffect(mx, my);

  // Hit ALL enemies within splash radius of click point (use center of enemy label)
  const toKill = [];
  for (const e of state.enemies) {
    const ex = e.x + 35; // approx half-width of label
    const ey = e.y + 10; // approx half-height
    const d = dist(mx, my, ex, ey);
    if (d <= splash) {
      const isCrit = Math.random() < state.upgrades.critChance;
      const dmg = isCrit ? Math.floor(atkPower * state.upgrades.critMult) : atkPower;
      e.hp -= dmg;
      showDamageNumber(e.x, e.y, dmg, isCrit);
      if (e.hp <= 0) toKill.push(e);
    }
  }
  for (const e of toKill) killEnemy(e);

  state.cooldown = w.cd * state.upgrades.cdMult;
}

function killEnemy(enemy) {
  state.score += enemy.score;
  state.kills++;
  state.xp += enemy.xp;
  state.waveEnemiesLeft--;
  state.waveKills++;
  // Drop chance
  if (Math.random() < 0.15 || enemy.elite) {
    spawnDrop(enemy.x, enemy.y, enemy.elite);
  }
  removeEnemy(enemy);
  checkLevelUp();
}

// ---- EFFECTS ----
function showAttackEffect(x, y) {
  const el = document.createElement('div');
  el.className = 'attack-effect';
  el.textContent = '×';
  el.style.left = (x - 9) + 'px';
  el.style.top = (y - 9) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 400);
}

function showDamageNumber(x, y, dmg, crit) {
  const el = document.createElement('div');
  el.className = 'damage-number' + (crit ? ' crit' : '');
  el.textContent = (crit ? 'CRIT ' : '-') + dmg;
  el.style.left = (x + rand(-15, 15)) + 'px';
  el.style.top = (y - 10) + 'px';
  canvas.appendChild(el);
  setTimeout(() => el.remove(), 800);
}

// ---- DROPS ----
function makeWeapon(rarity, wave) {
  const rarityIdx = RARITIES.indexOf(rarity);
  const baseName = WEAPON_NAMES[randInt(0, WEAPON_NAMES.length - 1)];
  return {
    id: Date.now() + Math.random(),
    name: baseName,
    rarity,
    atk: 8 + rarityIdx * 6 + randInt(0, 4 + wave),
    splash: 45 + rarityIdx * 15 + randInt(0, 10),
    cd: Math.round(Math.max(0.15, 0.6 - rarityIdx * 0.08 + rand(-0.05, 0.05)) * 100) / 100,
  };
}

function spawnDrop(x, y, guaranteed) {
  if (state.inventory.length >= state.maxInventory) return; // inventory full
  const rarity = guaranteed ? pickWeighted(RARITIES, [5, 15, 35, 30, 15]) : pickWeighted(RARITIES, RARITY_WEIGHTS);
  const weapon = makeWeapon(rarity, state.wave);

  const drop = {
    id: weapon.id,
    x: x + rand(-20, 20),
    y: y + rand(-10, 10),
    weapon,
    ttl: 10,
    el: null,
  };

  const el = document.createElement('div');
  el.className = 'drop ' + rarity;
  el.textContent = `[${weapon.name}]`;
  el.style.left = drop.x + 'px';
  el.style.top = drop.y + 'px';
  el.addEventListener('click', (ev) => {
    ev.stopPropagation();
    pickupDrop(drop);
  });
  canvas.appendChild(el);
  drop.el = el;
  state.drops.push(drop);
}

function pickupDrop(drop) {
  if (state.inventory.length >= state.maxInventory) return;
  state.inventory.push(drop.weapon);
  if (drop.el) drop.el.remove();
  state.drops = state.drops.filter(d => d.id !== drop.id);
  renderInventory();
}

function equipWeapon(weapon) {
  // Swap current weapon into inventory, equip new one
  const old = { ...state.weapon };
  state.weapon = { name: weapon.name, rarity: weapon.rarity, atk: weapon.atk, splash: weapon.splash, cd: weapon.cd };
  state.inventory = state.inventory.filter(w => w.id !== weapon.id);
  state.inventory.push(old);
  renderInventory();
  updateHUD();
}

function trashWeapon(weapon) {
  state.inventory = state.inventory.filter(w => w.id !== weapon.id);
  renderInventory();
}

function renderInventory() {
  const container = document.getElementById('inv-list');
  document.getElementById('inv-count').textContent = state.inventory.length;
  container.innerHTML = '';
  for (const w of state.inventory) {
    const row = document.createElement('div');
    row.className = 'inv-item ' + w.rarity;
    row.innerHTML = `<span class="inv-name">${w.name}</span><span class="inv-stats">A${w.atk} S${w.splash} C${w.cd}</span><span class="inv-trash">✕</span>`;
    row.querySelector('.inv-name').addEventListener('click', (ev) => { ev.stopPropagation(); equipWeapon(w); });
    row.querySelector('.inv-trash').addEventListener('click', (ev) => { ev.stopPropagation(); trashWeapon(w); });
    container.appendChild(row);
  }
}

function updateDrops(dt) {
  for (const d of [...state.drops]) {
    d.ttl -= dt;
    if (d.ttl <= 0) {
      if (d.el) d.el.remove();
      state.drops = state.drops.filter(dd => dd.id !== d.id);
    } else if (d.ttl < 3) {
      if (d.el) d.el.style.opacity = d.ttl / 3;
    }
  }
}

// ---- LEVEL UP (Skill Point System) ----
function checkLevelUp() {
  while (state.xp >= state.xpToNext) {
    state.xp -= state.xpToNext;
    state.level++;
    state.sp++;
    state.xpToNext = Math.floor(state.xpToNext * 1.5);
  }
  renderUpgradePanel();
}

const SKILL_POOL = [
  { id: 'atk', name: 'ATK +20%', cost: 1, maxLv: 10, apply: () => { state.upgrades.atkMult += 0.2; } },
  { id: 'cd', name: 'CD -10%', cost: 1, maxLv: 8, apply: () => { state.upgrades.cdMult = Math.max(0.1, state.upgrades.cdMult * 0.9); } },
  { id: 'splash', name: 'Splash +20%', cost: 2, maxLv: 5, apply: () => { state.upgrades.splashMult += 0.2; } },
  { id: 'crit', name: 'Crit +10%', cost: 1, maxLv: 6, apply: () => { state.upgrades.critChance = Math.min(0.8, state.upgrades.critChance + 0.1); } },
  { id: 'critdmg', name: 'CritDMG +50%', cost: 2, maxLv: 5, apply: () => { state.upgrades.critMult += 0.5; } },
  { id: 'trace', name: 'Trace -10%', cost: 2, maxLv: 5, apply: () => { state.upgrades.traceReduce = 1 - (1 - state.upgrades.traceReduce) * 0.9; } },
];

function renderUpgradePanel() {
  const container = document.getElementById('upgrade-list');
  const spEl = document.getElementById('hud-sp');
  spEl.textContent = state.sp;
  container.innerHTML = '';
  for (const skill of SKILL_POOL) {
    const lv = state.skillLevels[skill.id] || 0;
    const canBuy = state.sp >= skill.cost && lv < skill.maxLv;
    const row = document.createElement('div');
    row.className = 'upgrade-row';
    row.innerHTML = `<span>${skill.name} (${lv}/${skill.maxLv})</span>`;
    const btn = document.createElement('button');
    btn.className = 'upgrade-btn';
    btn.textContent = `[${skill.cost}SP]`;
    btn.disabled = !canBuy;
    btn.addEventListener('click', (ev) => {
      ev.stopPropagation();
      if (state.sp >= skill.cost && (state.skillLevels[skill.id] || 0) < skill.maxLv) {
        state.sp -= skill.cost;
        state.skillLevels[skill.id] = (state.skillLevels[skill.id] || 0) + 1;
        skill.apply();
        renderUpgradePanel();
        updateHUD();
      }
    });
    row.appendChild(btn);
    container.appendChild(row);
  }
}

// ---- WAVES ----
function startWave() {
  const count = 5 + state.wave * 3;
  state.waveEnemiesLeft = count;
  state.waveKills = 0;
  state.waveKillTarget = Math.ceil(count * 0.7);
  state.waveTimer = 0;
  showWaveBanner(`// WAVE ${state.wave} — ${count} TARGETS //`);
  // Spawn initial batch
  const initial = Math.min(count, 5);
  for (let i = 0; i < initial; i++) setTimeout(() => spawnEnemy(), i * 300);
  state.waveSpawnLeft = count - initial;
}

function showWaveBanner(text) {
  const banner = document.getElementById('wave-banner');
  banner.textContent = text;
  banner.style.display = 'block';
  setTimeout(() => { banner.style.display = 'none'; }, 2000);
}

// ---- HUD ----
function updateHUD() {
  document.getElementById('hud-wave').textContent = state.wave;
  document.getElementById('hud-level').textContent = state.level;
  document.getElementById('hud-xp').textContent = state.xp;
  document.getElementById('hud-xp-max').textContent = state.xpToNext;
  document.getElementById('hud-score').textContent = state.score;
  document.getElementById('hud-kills').textContent = state.kills;
  document.getElementById('hud-sp-top').textContent = state.sp;
  const tracePct = Math.min(100, Math.floor(state.trace));
  document.getElementById('hud-trace-pct').textContent = tracePct;
  document.getElementById('trace-fill').style.width = tracePct + '%';
  const traceBar = document.getElementById('trace-bar');
  traceBar.className = 'trace-bar' + (tracePct >= 70 ? ' danger' : '');
  const w = state.weapon;
  document.getElementById('hud-weapon').textContent = `${w.name} [${w.rarity.charAt(0).toUpperCase() + w.rarity.slice(1)}]`;
  document.getElementById('hud-atk').textContent = Math.floor(w.atk * state.upgrades.atkMult);
  document.getElementById('hud-splash').textContent = Math.floor((w.splash || 30) * state.upgrades.splashMult);
  document.getElementById('hud-cd').textContent = (w.cd * state.upgrades.cdMult).toFixed(2);
  updateCrosshair();
}

// ---- GAME OVER / WIN ----
function showResult(won) {
  state.running = false;
  const overlay = document.getElementById('result-overlay');
  const title = document.getElementById('result-title');
  const stats = document.getElementById('result-stats');
  title.textContent = won ? '// NETWORK COMPROMISED //' : '// TRACED — CONNECTION LOST //';
  title.style.color = won ? '#00ff41' : '#ff4444';
  stats.innerHTML = `SCORE: ${state.score}<br>KILLS: ${state.kills}<br>WAVE: ${state.wave}<br>LEVEL: ${state.level}`;
  overlay.classList.add('active');
}

// ---- MAIN LOOP ----
let lastTime = 0;
function gameLoop(timestamp) {
  if (!state.running) return;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;

  if (!state.paused) {
    // Trace
    const traceRate = Math.max(0.15, (TRACE_PER_SEC + state.wave * 0.05) * (1 - state.upgrades.traceReduce));
    state.trace += traceRate * dt;
    if (state.trace >= 100) {
      showResult(false);
      return;
    }

    // Cooldown
    if (state.cooldown > 0) state.cooldown = Math.max(0, state.cooldown - dt);

    // Auto-attack while holding mouse (all attack logic goes through here)
    if (mouseDown && state.cooldown <= 0) {
      if (state.mouseY >= CANVAS_PAD_TOP && state.mouseY <= window.innerHeight - CANVAS_PAD_BOT) {
        attack(state.mouseX, state.mouseY);
      }
    }

    // Spawn remaining enemies in wave
    state.waveTimer += dt;
    if (state.waveSpawnLeft > 0 && state.waveTimer > 1.5) {
      state.waveTimer = 0;
      spawnEnemy();
      state.waveSpawnLeft--;
    }

    // Check wave complete (kill 70% of wave to advance; survivors carry over)
    if (state.waveKills >= state.waveKillTarget) {
      state.wave++;
      if (state.wave > 20) {
        showResult(true);
        return;
      }
      startWave();
    }

    updateEnemies(dt);
    updateDrops(dt);
  }

  updateHUD();
  requestAnimationFrame(gameLoop);
}

// ---- INPUT ----
let mouseDown = false;
const crosshairEl = document.getElementById('crosshair');
document.addEventListener('mousemove', (e) => {
  state.mouseX = e.clientX;
  state.mouseY = e.clientY;
  crosshairEl.style.left = e.clientX + 'px';
  crosshairEl.style.top = e.clientY + 'px';
});
function updateCrosshair() {
  const splash = (state.weapon.splash || 30) * state.upgrades.splashMult;
  const size = splash * 2;
  crosshairEl.style.width = size + 'px';
  crosshairEl.style.height = size + 'px';
}
document.addEventListener('mousedown', (e) => {
  if (e.button !== 0) return;
  mouseDown = true;
});
document.addEventListener('mouseup', (e) => {
  if (e.button === 0) mouseDown = false;
});

// ---- START ----
function init() {
  state.running = true;
  lastTime = performance.now();
  startWave();
  renderUpgradePanel();
  renderInventory();
  updateHUD();
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
